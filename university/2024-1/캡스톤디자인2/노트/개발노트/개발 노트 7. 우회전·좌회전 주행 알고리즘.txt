주행 알고리즘 및 예외처리



1.
차체의 기울어짐 때문인지, 벽뚤림우회전인지,
->
구분할 수 있어야 함.




1.
우측 둘 다 뚤려야 우회전 하는데,
우측 앞에 센서 먼저 뚤릴 때,
->
아니,
벽이 뚤린 걸 확인하는 건,
dr1로 충분히 확인 가능하다고 생각.
ㅇ.ㅇ
->
위험상황
	1. 절벽이, 우측센서 물리적 거리 보다 클 때.





// 앞에도 뚤려있어야 함.

//





방법

1.
결국 두 개 센서 모두 뚤렸을 때.



1.
회전 초반에 확인.
->
클락사용중이고, mainLoop는 계속 돌고 있고, 다른 센서를 어떻게 쓸 것인가는, 충분히 코드 변경 가능한 상황




->
코드 구현할 때,
dr1 벽뚤림 확인
->
내부코드로 회전 조건 구현.



그,
여기 안에서는,
초음파센서 측정을 멈추도록 하자.
차체가 얼마나 휘어있겠어?


dr1 못 씀.
->
dr2는, dr1이랑 짝궁으로 기울기 측정해서 직진기울기 제어하는거라서, 못 씀.






일정거리 이상 뚤려있는 건, 50cm로 고정.

갑자기 차이가 나는 값은, 


->
50으로 고정을 한다.


그렇게 된다면,

우측2센서로 기울기 계산해서 직진주행 중 기울어짐을 확인하는데,
모든 센서가 50으로?


모든 센ㅅ ㅓ최대값이 50




ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
->
조건문 내부.
=>
최대값이 50이라면,

우측 전방센서는 50이 되고.

우측 후방센서는 50보다 작은 const가 되고,

기울기를 측정하는 알고리즘은, 우측 2센서를 비교해서 측정하고, 그게 주행 중 차체의 기울기를 변경하는데,

우측 전방이, 1100인 건 물론 막아야 해서 50으로 고정하는 건 좋지만,

20 과 50 도, 기울어짐 차이가 너무 심해서,

저 조건문 내부에 있을 때, 직진주행 코드 실행하면, 차체 안쪾으로 확 기울어질 듯.





기울기 변경에 


판단 알고리즘이 전 값이랑 바로 전 측정 값이랑 비교해서,
차이를 비교 해서.


뚤린 벽이라 판단.

->
뚤린 벽일 때 문제 발생.




기울기를 계산하는 데 사용하는 소스 두 개.
1. 우측 전방 센서.
2. 
거리 비교 알고리즘
전값 변수 이름을 past로 지정 현재측정값과 past값의 차이를 구하여 조건에 맞는지 판단 후 현재 측정값을 past값에 저장 후 다시 현재값을 측정하였을때 다시 차이를 구하는 무한반복
->

전값현재값 비교 ->
회전할 때 조건으로 둠.



현재값과 과거값을 비교.
->




ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
->
회전 조건 들어갔을 때.




문제
1.
최대값이 50이라면,

우측 전방센서는 50이 되고.

우측 후방센서는 50보다 작은 const가 되고,

기울기를 측정하는 알고리즘은, 우측 2센서를 비교해서 측정하고, 그게 주행 중 차체의 기울기를 변경하는데,

우측 전방이, 1100인 건 물론 막아야 해서 50으로 고정하는 건 좋지만,

20 과 50 도, 기울어짐 차이가 너무 심해서,

저 조건문 내부에 있을 때, 직진주행 코드 실행하면, 차체 안쪾으로 확 기울어질 듯.











그,
벽이 뚤렸을 때,
우측 전방 센서값은, 어떤 값으로 대체할 것인가?

우측 2센서 값 -> 차체 기울기 측정 0-> 차체 기울기 변경.
우측 전방 센서값이 50이라 해도, 우회전 조건 코드 내부에서, 기울기 변경이 없어야 해.

기울기 변경.

직진 안 함.




// 전방측정 가능.



우회전 알고리즘 정리
->
dr1 뚤림		// 현재값 전값
->
dr1측정 안 함, 직진함수 실행 안 함(차체기울기변경 안 함.)
dr2 측정.
->
dr2가 뚤리면, 우회전!
dr2가 뚤리기 전에 dr1이 돌아오면, 직진.









ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ endline










주행 알고리즘2

pseudo



1.
거리값을 사용하는 건, 주행 함수 3개 뿐이다.



1.
초음파 센싱 계속하고, 거리값도 계속 업데이트한다.

거리값을 사용하는 주행 함수 3개에 대해서만, 함수 실행을 제어한다.



1.
주행으로 사용할 거리값의 오류 및 예외처리에서, 이전의 거리값을 사용하지 않는다.

거리값을 사용하는 주행 함수가, 거리값의 신뢰성을 검사한다.
->
new와 prev 비교, const 이상 차이나면,
->
두 스테퍼 속도를 0.8로 고정시켜, 기울기를 변경하지 않고 가던 길 1자로 간다.

여기서 예외처리 두 가지
	1.
new가 noise일 경우,
->




const는 상당히 작게 한다.
->
각 초음파는 2.5회/1  ==  1회/0.4s
->
const는 2 혹은 3cm로 한다.				// 얇은 벽의 짧은 좌회전 이후 dr1, dr2는 직각 벽을 그대로 읽어야 하므로, 5cm 이상으로 해야 한다.


new1과 prev 비교, const 이상 차이나면, noise라 보고 적용하지 않음.
->
new1은 다음 new2와 const 이상 차이나지 않으면, new2를 적용한다.    -    차이나면, 무시한다.



->
반복하는 걸 구현하면 돼.






절대로 ISR에서 거리값 원본인 dist 배열을 건들지 말 것.



직진 함수를 생각해봐.
->
noise라 판단하면, 이전 값을 사용해.


문제
1.
연속되는 최대거리값은 [new - prev < const]이므로 noise가 아니다.
->
600 이상 값은, 무시.		// 600 아님. 제대로 정해.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
어떻게 무시?

그냥 무시.
처리하지 않는다.










ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ dist 판별

if (dr1[0]

-const < dr1[0] - dr1[1] < const
->
DR1 = dr1[0]











-->
dr1, dr2를 판별하면, 각각의 사용할 거리값 DR1, DR2가 남는다.
사용할 거리값이 남는다.		// 거리값을 DR1, DR2라 한다.
<직진>은 DR1, DR2를 그대로 사용하면 된다.

<우회전>과 <좌회전>은?


우회전 조건
->
newDist가 prev에 +300mm 이상이면 벽뚤림이라 본다.
300mm를 const라 한다.
->
dr1[0] > (DR1 + const)
&&
dr2[0] > (DR2 + const)    ||    dr2[1] > (DR2 + const)



좌회전 조건
->
이거, 센서에 안 잡히는데 부딛힐 수도 있을 텐데.
오로지 좌회전을 하기 위한 전방 2센서라면,
좌회전만 성공해도 되니까,
->
전방 2센서는 최대한 끝에, 바깥으로 5도 틀어서 설치한다.
->
df1이 






90도 좌회전 조건의 거리를 const라 한다.

if (df1 < const)
{
	if (df2 < const)
	{
		turnLeft();
	}
	else
	{
		clk_start = micros();
		
		
	}
}



























우회전 어떻게?
->
dist배열을 직접 확인한다.
->
(new - 이전값) > 300
->












!! 거리값 받고 주행함수 시작 전에, dist 판별하면 되겠네.
































ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ endline















// dist 판별				// 200은, 우회전 조건에도 동일하게 사용될 거리값. -> 많이 틀어지는지, 측정해보고 값 정해.
if (dr1[0] < DR1 + 200)
{
	if (-Const < (dr1[0] - dr1[1]) < Const)				// Const는 50mm.
	{
		DR1 = dr1[0];
	}
}

if (dr2[0] < DR2 + 200)
{
	if (-Const < (dr2[0] - dr2[1]) < Const)
	{
		DR2 = dr2[0];
	}
}

if (df1[0] < DF1 + 200)
{
	if (-Const < (dF1[0] - dF1[1]) < Const)				// Const는 100mm
	{
		DF1 = dF1[0];
	}
}

if (df2[0] < DF2 + 200)
{
	if (-Const < (df2[0] - df2[1]) < Const)				// Const는 100mm
	{
		DF2 = df2[0];
	}
}



// 좌회전
if (DF1 < Const || DF2 < Const)
{
	// 제자리 좌회전
}


// 우회전
if (dr1[0], dr2[0, 1] > dr1[1] + 200)
{
	// 제저리 우회전
}




/*
	dist 판별 코드는,
	ISR에서 해도 될 듯?
	실행시간 10us 이내인데.





	!! 직선 주행에서, DR1, DR2가 업데이트되지 않아서, 스테퍼 속도 변경이 되지 않으면, 두 스테퍼 속도는 1로 고정해야 한다.
	정상 주행 상황은 아니기 때문에, 1보다는 0.8 ~ 0.9로 하면 좋으려나?
	->
	1로 고정 안 해도 될 것 같아. 냅두자.
*/







ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ endline