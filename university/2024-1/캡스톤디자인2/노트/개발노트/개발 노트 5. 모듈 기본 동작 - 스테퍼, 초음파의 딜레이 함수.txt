_10






아두이노의 delay() 함수는, 실행 시간이 정해진 함수 코드일 뿐이다.

아두이노에서 delay(), pulseIn() 등의 블로킹 함수는, 실행 시간이 정해진 코드일 뿐이며, 보드가 멈추는 건 아니다.
따라서 ISR 또는 millis()가 반환하는 보드 가동시간과 같은 HW적 요소에 영향을 끼치지 않는다.
// 1000ms delay에서 400ms 즈음 interrupt 발생 및 ISR 끝나면 나머지 600ms 마저 실행한다.





부품들이 충돌하지 않게, 보드의 핀맵에 따라 잘 배치했다고 가정한다.

그럼에도 분명,
다른 코드들에 의해서 모터의 작동이 지연될 거라 확신한다.



걸리는 연산 두 가지
->
1.
mapping

2.
초음파 거리 계산.




ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ 스테퍼 모터

마이크로스텝 없이 기본 스텝으로 한다.
스텝 사이 딜레이는 1~10ms 정도 된다.
->
모터 딜레이를 millis()로 하는 것에 대해 검토해봐야 한다.

1.
지정한 딜레이보다 더 오래걸리는 연산이 있는지?

2. 
있다면, millis() 연산을 통해 밀린 만큼 빠르게 가는 것은 문제가 있을지?





ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ 초음파 센서



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ 일반적인 코드

const int trigPin = 2; // 초음파 송신 핀
const int echoPin = 3; // 초음파 수신 핀

void setup() {
  Serial.begin(9600); // 시리얼 통신 초기화
  pinMode(trigPin, OUTPUT); // 초음파 송신 핀을 출력 모드로 설정
  pinMode(echoPin, INPUT); // 초음파 수신 핀을 입력 모드로 설정
}

void loop() {
  long duration;
  int distance;

  digitalWrite(trigPin, LOW); // 초음파 송신 전압 초기화
  delayMicroseconds(2); // 2 마이크로초 동안 기다림

  digitalWrite(trigPin, HIGH); // 초음파 송신 신호를 보냄
  delayMicroseconds(10); // 10 마이크로초 동안 유지
  digitalWrite(trigPin, LOW); // 초음파 송신 신호를 중지

  duration = pulseIn(echoPin, HIGH); // 초음파 신호가 수신될 때까지의 시간을 측정
  distance = duration * 0.034 / 2; // 거리를 센티미터 단위로 계산

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ






pulseIn(pinNumber, state-LOW/HIGH) 함수는, pinNumber가 state가 될 때까지 최대 1초 기다리고, 최대 3분의 state 펄스의 길이를 microsecond로 반환한다.
overloading -> pulseIn(pinNumber, state-LOW/HIGH, timeoutDuration)
delay()와 같은 블로킹 함수이다.
기본 timeout = 1s    ->    return 0

초음파 센서의 수광부와 연결한 echo핀은 초음파를 송신한 순간부터 모두 수신할 때까지 HIGH 상태이므로,
pulseIn() 함수로 HIGH 펄스 길이를 체크하는 것으로 거리를 계산할 수 있다.






ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ 코드 분석

초음파 송신 시간은 10us으로 매우 짧기 때문에, 예제와 동일하게 delay()로 처리한다.

// 10us 동안 초음파 거리는 3.4mm로, 매우 작은 오차이다.

pulseIn() 최대 시간 계산
->
초음파 센서 최대 측정 거리는 400cm  ->  왕복 거리는 8m
초음파 속도는 340m/s
->
최대 왕복 시간 : 23.5ms
->
timeoutDuration을 23.5ms로 설정한다.
// 나중에 초음파 센서를 직접 테스트하여 측정한 거리로 설정할 수도 있다.





pulseIn() 처리시간이 어떻게 될까?
->
측정 시간 혹은 최대 timeoutDuration이다.
->
최대 23.5ms




초음파 센서는 4개.
각 초음파 센서는 적어도 1초에 한 번은 체크한다고 할 때,
가까운 거리보다 먼 거리를 측정하는 경우가 더 많으므로,
4개의 초음파 센서로 인한 지연은 대략 1초에 0.1s, 10%이다.
->
항시 동작하는 스테퍼 모터에 지대한 영향을 끼친다.




pulseIn() 대신 외부 인터럽트를 사용한다면 어떨까?

초음파 센서는 4개이므로, MEGA에 탑재된 MCU의 외부 인터럽트 핀번호를 확인하자.
->
arduino MEGA : 2, 3, 18, 19, 20, 21



코드 구성은 대강 다음과 같다.
->
초음파 on
10us
초음파 off

(pulseIn() 대신에)
전역변수에 micros() 저장.
ISR - fallingEdge trigger { 전역변수 = micros() - (이전 micros()값인 전역변수) }
( -> 기존 pulseIn() 반환값 대신에 전역변수값을 사용하면 된다.)








모든 아두이노 보드에서 시간 관련 처리는 timer0이다.

일부 아두이노 보드를 제외하고, micros() 반환값의 해상도는 4이다.

overflow
->
millis() : 49.7d
micros() : 71.6m

ISR에서 모든 인터럽트는 비활성화된다.












문제
1.
millis(), micros()는 interrupt와 충돌하는가??

2.
출력핀을 개별로, 입력핀을 하나로 할 수 있는가???






1번
->
_delay_ms(), _delay_us()는 AVR-GCC library의 함수이다.
타이머 인터럽트를 사용하지 않으며, __builtin_avr_delay_cycles()라는 내장 함수를 호출하여 CPU 사이클을 기반으로 지연을 생성한다.

delay()는 타이머 인터럽트에 의존하여 작동한다.

delayMicroseconds()는 CPU cycle을 직접 계산하며, 인터럽트를 사용하지 않는다.



millis()는 타이머 인터럽트에 의해 업데이트되므로, ISR에서 값이 변경되지 않는다.

micros()는 하드웨어 타이머의 값을 읽는다.
3~16383us에서 정확하며, 그 이상에서는 함수가 CPU cycle을 세는 방식에서 매우 짧은 지연을 생성할 수 있다.







2번
->
초음파 센서의 에코 핀을 하나로 공유하는 경우에 대해 다시 검토해보았습니다.
각 센서가 독립적으로 실행된다고 가정할 때, "동시 작동 회피, 에코 신호 혼선 방지, 타이밍 관리, 프로그램 로직"에 대한 문제는 발생하지 않을 것입니다.
그러나 에코 핀을 공유할 때 고려해야 할 추가적인 사항들이 있습니다.

전기적 간섭: 에코 핀을 공유할 때, 각 센서의 출력이 서로 간섭하지 않도록 하기 위해 전기적인 조치가 필요할 수 있습니다. 예를 들어, OR 게이트 IC를 사용하여 여러 센서의 출력을 결합할 수 있습니다.
하드웨어 설계: 공유된 에코 핀에 대한 하드웨어 설계가 적절히 이루어져야 합니다. 예를 들어, 각 센서의 출력을 안전하게 결합하기 위해 다이오드를 사용할 수 있습니다.
소프트웨어 로직: 각 센서의 트리거와 에코 신호를 관리하는 소프트웨어 로직이 정확해야 합니다. 이는 각 센서의 신호를 정확히 구분하고 처리하기 위함입니다.
신호 경로 최적화: 신호 경로를 최적화하여, 신호의 전송과 수신이 정확하게 이루어지도록 해야 합니다. 이는 신호의 지연이나 손실을 최소화하기 위함입니다.
이러한 사항들을 고려하여 설계와 프로그래밍을 진행한다면, 에코 핀을 공유하면서도 각 센서의 데이터를 정확하게 읽을 수 있을 것입니다.
그러나 실제 구현 시에는 신중한 테스트와 검증이 필요합니다. 따라서, 제시된 답변은 기본적인 원리에 대해 올바르게 설명하고 있으며, 실제 구현 시에는 신중한 테스트와 검증이 필요할 것입니다.







!! ISR은 가능한 한 빠르게 처리되어야 한다.

공홈 -> https://www.arduino.cc/reference/ko/language/functions/external-interrupts/attachinterrupt/
정리
->
ISR 내에서 delay()가 작동하지 않고, millis() 반환값이 증가하지 않는다.

ISR 실행 동안, 수신된 직렬 데이터가 손실될 수 있다.

ISR 내에서 변경할 모든 변수는 volatile로 선언해야 한다. (외부 입력을 저장하는 변수로서 반드시 volatile 선언한다.)

millis()는 인터럽트를 사용하여 계산하므로 ISR 내부에서 증가하지 않는다.

delay()는 인터럽트가 필요하므로 ISR 내부에서 호출하면 작동하지 않는다.

micros()는 처음에는 작동하지만, ISR 실행 1-2ms 후에 이상하게 작동하기 시작한다.

delayMicroseconds()는 카운터를 사용하지 않으므로 정상적으로 작동한다.












코드 구성 다시
->
초음파 on
10us
초음파 off

(pulseIn() 대신에)
전역변수에 micros() 저장.
ISR - fallingEdge trigger { 전역변수 = micros() - (이전 micros()값인 전역변수) }
( -> 기존 pulseIn() 반환값 대신에 전역변수값을 사용하면 된다.)



!! 절대로 지연이 있어서는 안 된다.


!! 예상 오류
->
1.
인터럽트로의 평균 진입 시간.

2.
예외적인 인터럽트 지연 시간.





!! 반드시 거리 검증 수시로 할 것.




// 공홈 마지막 줄 : 인터럽트 사용에 대해서
->
이것과 인터럽트 문법 검색을 참고해서 코드 작성.











ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
아두이노에서 인터럽트 지연 시간, 즉 인터럽트가 발생하고 ISR(Interrupt Service Routine)이 시작되기까지의 시간은 일반적으로 매우 짧습니다. 이 지연 시간은 대부분의 경우 몇 마이크로초에서 수십 마이크로초 사이입니다12. AVR 마이크로컨트롤러를 사용하는 아두이노 보드의 경우, 인터럽트 실행 응답 시간은 최소 4 클록 사이클이라고 알려져 있습니다3.

인터럽트 지연 시간은 다음과 같은 요소들에 의해 영향을 받을 수 있습니다:

1. CPU의 현재 실행 중인 명령을 완료하는 데 걸리는 시간
2. 현재 작업 상태를 저장하는 데 필요한 시간
3. ISR로 점프하는 데 필요한 시간
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ








































ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ endline