_1

오른쪽 벽을 따라 간다.

4개의 초음파 센서를 사용하며,

2센서는 전방, 2센서는 우측 벽과의 거리를 체크한다.



기본은 직진이며, 조건에 따라 좌회전과 우회전을 한다.

직진 알고리즘부터 작성해보자.







목적 : 안정적인 직진
->
우측의 두 센서 중 앞을 센서1, 뒤를 센서2라고 한다.
벽과의 거리는 ??cm로 하고, 이를 상수로 둔다.
->
센서1, 센서2는 상수값을 유지해야 한다.
->
센서1, 센서2의 차이로 차체의 기울기를 측정하고, 센서1의 값과 기울기로 벽과의 정확한 거리를 계산하고, 스테퍼를 제어한다.



초음파 센서의 값은 기울기에 따라 늘어나고, 어느 이상에서는 반사된 초음파를 받지 못해 오작동이 일어난다.
회전도 당연히 포함이기 때문에, 회전 코드는 분리한다.
->
각도와 거리가 얼마나 유효한지 측정해보자.
->
20cm 이하에서 최대 각도는 35도이며, 삼각함수로 거리 계산이 유효하다고 판단된다.
20cm 이상에서 삼각함수 거리 계산의 의미가 점차 사라지고, 극단적으로 200cm에서는 20도를 틀어도 205cm라고 측정된다.
->
직선 주행 코드를 실행하는 동안에, 이 각도 이상 틀어지지 않는다는 조건을 걸어야 한다.



// 기울기를 단계별로 정의할지는 의문.



삼각함수 거리 계산
->
벽과의 수직거리가 a이고 theta만큼 기울였을 때, 기울인 선의 길이 x는 x = a / cos(theta)















센서1, 센서2는 상수값을 유지해야 한다.
->
차체는 const로 가야 하고, const에서 최대한 직선 주행을 해야 한다.

센서와 const의 거리가 멀면, 가파르게 const로 접근하고,
거리가 가깝다면, 완만하게 가야 한다.
// 완만하게 가지 않으면, 탈조 위험이 있다. (뒤에서 다룬다.)
->
목표 기울기는 (센서값 - const)와 비례하게 하고,
현재 기울기는 (두 센서값의 차이)와 비례하게 한다.

현재 기울기는, 목표 기울기로 다가가야 한다.

거리는 우선 mm 단위로 한다.

우측 2센서, 앞이 d1, 뒤가 d2,
두 센서 사이 거리는 100mm라고 한다.

const는 100mm로 한다.

d1 ->
d2 ->
             constLine             wall













(우측 2센서 거리) = 100mm

const = 100

목표 기울기 : targetSlope
현재 기울기 : currSlope

스테퍼1의 속도 : ratio1
스테퍼2의 속도 : ratio2



targetSlope  =  (d1 - const)                        // 차체와의 거리이기 때문에 const - d1이어도 돼.
currSlope  =  (d1 - d2)



target(d1 - const) = (+) 100
-> (비례 적용)
curr(d1 - d2) : (-) 20

-->
거리가 100이라면, 기울기는 20으로 둔다.
// 기울기 20은, 2센서 거리가 100이므로, 차체의 실제 기울기는 12도로 충분하다.  ->  ? 좀 더 가파르게 가자.  기울기값 30이라면? 차체기울기는 17도.
// 이거, 이런 근거리에서 저 초음파센서가 35도까지 된다고 했으니까, 최대 기울기는 일단 25로 둘까?  ->  차체기울기 25에서 기울기값 (d1 - d2)는, (2센서 거리)의 42%이다.
// (2센서 거리)를 dd라고 정의한다.
--> 다시 정리
target(d1 - const) = (+) 100
-> (비례 적용)
curr(d1 - d2) : (-) 0.42dd


차체기울기의 최대값은 curr(d1 - d2) < 0.42dd로 한다.


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
거리가 멀 때,
->
(d1 - const) > 0



1.
(d1 - const) > 50
->
target(d1 - d2) = 0.42dd 고정.



2.
0 < (d1 - const) < 50
-> (비례 적용)
(d1 - const) : target(d1 - d2) = 50 : 0.42dd





ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
거리가 가까울 때,
->
(d1 - const) < 0



조건은 하나만 두자.
위의 2번과 동일하게 가되, 50 이하의 범위는 없애자.

최대 차체기울기를 25도로 정했는데,
거리가 멀 때, 거리 50 이상에서 최대 기울기를 두었다.
거리가 가까울 때, 거리 50 이상에서는, 벽 덕분에 최대 기울기에 도달하기 전에 거리 50 이하에 들어오기 때문에, 최대 기울기를 두지 않아도 된다.
// 거리 0에서 많이 기울어져서 오작동 일어나면, 그때 가서 수정하자.

1.
(d1 - const) < 0
-> (비례 적용)
(d1 - const) : target(d1 - d2) = 50 : 0.42dd
















목표 기울기는 정했다.

이제, 현재 기울기가 목표 기울기를 따라가야 한다.

기울기를 변경하려면, 두 스테퍼의 속도를 달리 하면 된다.
->
두 스테퍼의 속도가 다를 때, 기울기가 변경된다.

기울기가 변경되는 정도는, 두 스테퍼의 속도 비율이다.
// 여기서, 두 스테퍼의 속도 비율이 같아도, 실제 물리적으로 차체와 속도값에 따라 다를 거라고 생각한다.

stepDelay1 = (unsigned long)((1. / (stepperSpeed1 * ratio_stepperSpeed1)) * (double)const_stepDelay);

stepperSpeed는 외부에서 원격 제어할 속도이다.

ratio_stepperSpeed가 오로지 주행에 사용된다.
->
기본값은 1.0



// 부호는 나중에 생각하자.



target(d1 - d2)를 target이라 하고,
curr(d1 - d2)를 curr이라 하자.



(target - curr)에 비례하여 ratio를 변경한다.


비율 정해야 되는데.

값이 어떻게 되는데?


(target - curr) 값은, 최대값은,
차체는 왼쪽 최대 기울기인데, 목표는 오른쪽 최대 기울기라면,
0.42dd * 2 = 0.84dd : 최대값.



ratio = 1 - 0.84dd



































































ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
거리가 멀어져 있을 때 한정이지만,
목표 기울기를 결정하는 건 완성했다.

이제, 그 목표 기울기로 어떻게 갈 것인가?



















































할 일
->
차체의 기울기 계산.




센서1 - 센서2 > 0
->
바깥쪽.





















const 이상이면,
(d1 - const)에 비례하여 (안쪽으로의) 기울기 생성.

const 이하이면,
(d1 - const)에 비례하여 (바깥쪽으로의) 기울기 생성.





그 기울기가 될 때까지, ratio_stepperSpeed(1, 2) 제어.








	




























































ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ endline



_2

직진 주행.

거리는 mm 단위.

// 기울기에 따른 삼각함수 거리 계산은 하지 말자. 비율을 두 번이나 적용하여 constLine까지 너무 오래걸린다. 거리를 더 크게 측정하게 두자. 더 빨리 기울어지게.


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ 1번

목표 위치는 const이며, 차체와의 거리는 (d1 - const)로 표현한다.

거리가 멀면 가파르게 이동하고, 가까워지면 완만하게 이동한다.
->
원하는 차체의 기울기는 (d1 - const)로 표현할 수 있고, 이를 (목표 기울기)라고 한다.
현재 차체의 기울기는 (d1 - d2)로 측정하고, 이를 (현재 기울기)라고 한다.
->
차체 특성을 활용하여, (d1 - const)의 목표 기울기를 (d1 - d2)로 표현하는 공식을 정한다.
->
이로써 (현재 기울기)와 (목표 기울기)를 비교할 수 있게 되어,
(현재 기울기)를 (목표 기울기)로 이동시킬 수 있다.








ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ 1번 풀이

초음파 센서 특성
->
20cm 이하에서 최대 각도는 35도이며, 삼각함수로 거리 계산이 유효하다고 판단된다.
20cm 이상에서 삼각함수 거리 계산의 의미가 점차 사라지고, 극단적으로 200cm에서는 20도를 틀어도 205cm라고 측정된다.

->
차체 기울기는 최대 25도로 한다.
sin(25도) ~= 0.423

(두 센서 사이의 거리)를 dd라고 하자.
->
(최대 기울기) : max(d1 - d2) = 0.42dd



(목표 기울기)를 target(d1 - d2)라 하자.

(d1 - const) 값에 따라 (목표 기울기)를 결정한다.

1.
(d1 - const) > 50
-> (목표 기울기)는 (최대 기울기)로 고정.
target(d1 - d2) = -0.42dd

2.
0 < (d1 - const) < 50
-> 매칭
0 > target(d1 - d2) > -0.42dd

3.
-const < (d1 - const) < 0
-> 매칭
0.42dd * const / 50 > target(d1 - d2) > 0
// 벽으로 막혀 있어 거리가 짧아서 최대 기울기에 도달하지 않는다고 가정한다.
















ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ 2번 및 풀이

stepDelay1 = (unsigned long)((1. / (stepperSpeed1 * ratio_stepperSpeed1)) * (double)const_stepDelay);
->
stepperSpeed는 외부에서 원격 제어할 속도이다.
ratio_stepperSpeed가 오로지 주행에 사용된다.
->
기본값은 1.0이다.

(스테퍼1의 속도) : ratio1
(스테퍼2의 속도) : ratio2

ratio를 줄이는 것으로 기울기를 변경한다.

ratio를 (1 - x)로 줄이는 양을 x라고 하자.

ratio1은 x만큼 바깥쪽(왼쪽)으로 기울어진다.
ratio2는 x만큼 안쪽(오른쪽)으로 기울어진다.

(기울기 변화량) = kx (k는 비례상수)



목표 기울기 근처에서는 기울기가 수시로 변하여, 차체에 대미지를 줄 수 있다.
->
멀리서는 가파르게, 근처에서는 완만하게 하기 위해 이 역시 비례를 적용한다.
->
(목표 기울기)와 (현재 기울기)의 차이와 비례하게 한다.

-0.42dd < (기울기) < 0.42dd



ratio1 = 1.0 - x1
ratio2 = 1.0 - x2



target(d1 - d2) - curr(d1 - d2) > 0
->
x1 감소

target(d1 - d2) - curr(d1 - d2) < 0
->
x2 감소



0 < x1 < 1.0
->
0 < (target - curr) < 0.84dd

0 < x2 < 1.0
->
0 > (target - curr) > -0.84dd















	










ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ endline






_3


주행 단계별 속도에 따라서 알고리즘에 달라질 것으로 예상됨.




전방 2센서가 가까울 때, 좌회전.

우측 2센서가 멀 때, 우회전.




문제점들
->
1.
전방 2센서 중 하나만 가까워질 때.
->
장애물 개념이 없으므로, 벽으로 인식하여 회전한다.
->
좌회전 조금, 우회전 조금의 회전 종류 하나 더 만들 수도 있겠다.

1.
우측 2센서 노이즈.
->
우측 2센서는 항상 일정 이상 값 무시.
벽과 떨어진 상황을 간주하지 않음.

1.
좌회전을 할 때, 주행 단계별 속도에 따라서 전방 2센서값을 달리 해야 한다.
회전은 별개의 코드로 둔다.
->
주행 단계별 속도에 따라서 알고리즘이 달라질 것으로 예상됨.
->
팀장이 속도는 하나로 통일한다고 한다.















ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

전방 2센서의 (왼쪽, 오른쪽) 측정 거리를 (df1, df2)라 하고,
우측 2센서의 (앞, 뒤) 측정 거리를 (dr1, dr2)라고 한다.

회전하기 위한 df, dr 값을 constF, constR이라 한다.

// 직선 주행 유지 거리는 const이다.

차체 특성상 회전 알고리즘은 실시간으로 제어할 수 없으며, 물리적으로 측정하여 대입해야 한다.
->
지금 정확한 수치는 제외하고 구상한다.





ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ 좌회전

좌회전 함수를 실행할 조건을 만든다.



1.
(df1 > constF) && (df2 < constF)
->
짧은 자회전과 우회전.



2.
(df1 < constF) && (df2 < constF)
->
좌회전.



좌회전 이후 const에 딱 맞게, constF를 정한다.





ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ 우회전

우회전 함수를 실행할 조건을 만든다.



1.
(dr1 > constR) && (dr2 > constR)
->
우회전.




우회전하기 전,
dr1과 dr2 값이 커지면, 직선 주행의 기울기에 관여하게 된다.
->
변화량만으로는 힘들다.
결국 일정 값 이상은 무시하는 것으로 해야 한다.
->
물리적으로 차체가 우회전 이후 즉시 자회전을 할 수 있는 최소 거리를 constR로 정한다.
->
constR 이상의 값은 distance에 포함하지 않는다.
단지 constR 이상일 때 dr1과 dr2 각 센서에 flag를 세운다.










































































































ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ endline











_4



문제
1.
기울기를 측정하려면,
dr1, dr2를 동시에 trigger해야 한다.
확인해보자.
->
초음파(1, 2), 초음파(3, 4)의 주기가 같아야 해.
수정하자.
->
초음파 트리거 함수를 하나로 통일하고 index, clk_trig, interval_trig 전부 하나로 사용한다.
그리고 distance 값에 따라 stepDelay를 계산하는 함수는, distance 값이 바뀔 때에만 계산하도록 한다.
->
초음파 ISR에서 fallingEdge 측정하고 distance 계산할 때, flag 세우자.
->
dr1, dr2를 동시에 트리거하면, 높은 확률로 간섭된다.
->
100ms의 딜레이를 둔다면, 기울기 계산에 오차가 얼마나 될까?
->
100ms동안 dd의 몇 퍼센트를 갔는가를 측정하고 감안하여 계산하면 되는데,,
->
측정 순서를 (dr1 -> dr2) 이렇게 하면,
기울기는 줄어든다.

측정 순서를 (dr2 -> dr1) 이렇게 하면,
기울기는 늘어난다.
->
늘리자!
비율 두 번이나 적용하는데,
기울기 늘려서 더 빠르게 가게 하자!
최대 기울기도 25도로 잡아서 넉넉한데. 좋네.
->
아니,
혹시 dr과 df가 서로 간섭되나?
확인해보자.
->
어찌되든 간섭 확률은 존재한다.
걸러내기 힘든데,
확실하게 가자.
->
100ms당 하나씩.
순서는,
dr2 -> dr1 -> df1 -> df2
index 쓰지 말고, 개별 distance 배열 갖도록 하자.
dr1[], dr2[], df1[], df2[]



























ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ endline















_5



트리거1, 2, 3, 4

트리거 1, 2 -> 에코 1
트리거 3, 4 -> 에코 2


트리거를 하나씩 실행.


ISR에서 실행 순서
트리거 1
트리거 2


두 개의 트리거가 하나의 에코인 건, 원래 아무 쓸모 없었어.
연결고리를 어떻게 할 거냐만 생각하면 돼.




TRIG[4]


count = 0, 1, 2, 3

트리거 = 0, 1, 2, 3

ISR1
->


ISR2
->



dr1
dr2
df1
df2


unsigned long distance[4][5] = { 0, };

unsigned long* dr2 = distance[0];
unsigned long* dr1 = distance[1];
unsigned long* df1 = distance[2];
unsigned long* df2 = distance[3];

ISR1
->
0
2

ISR2
->
1
3









ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ endline









_6



stepper1_oneStep()
->
조건들 중 뒤쳐지는 스텝을 최대 70%딜레이로 빠르게 실행하는 조건은, 의미가 없는 것 같다.



초음파 측정 후 flag를 세우고, flag로 주행 함수를 1회 실행하여 스텝딜레이를 구한다.
->
dr1 측정 -> dr2 측정 및 flag_straightAndTurnRight 세움.
df1 측정 -> df2 측정 및 flag_turnLeft 세움.





ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ endline










_7



모터의 스텝딜레이가 모든 주행을 결정한다.
모든 주행 함수는, 이 스텝딜레이를 한 번 결정한다.




Pseudo Code
->










bool isTurning = false;

unsigned long turnDuration = (회전 측정해야 돼.)

unsigned long clk_turnStart = 0;

// clk_turnEnd는 micros()가 대체한다.

bool isRightSensorsUpdated = false;
bool isFrontSensorsUpdated = false;









/*
dr1 -> dr2 값을 다 받으면, isRightSensorsUpdated = true
->
moveStraight(), turnRight() 함수의 조건을 1회 확인한다.

df1 -> df2 값을 다 받으면, isFrontSensorsUpdated = true
->
turnLeft() 함수의 조건을 1회 확인한다.



*/


mainLoop
<<<<<

if (트리거 쿨타임)
{
	trig();
}


if (isTurning == false)
{
	if (isRightSensorsUpdated == true)
	{
		if (우측 2센서 멀어짐)
		{
			isTurning = true;
			turnRight();
			clk_turnStart = micros();
		}

		moveStraight();
	}


	if (isFrontSensorsUpdated == true)
	{
		if (전방 2센서 근접)
		{
			isTurning = true;
			turnLeft();
			clk_turnStart = micros();
		}
	}
}
else
{
	if ((micros() - clk_turnStart) > turnDuration)
	{
		isTurning == false;

		{
		index_ultrasonic = 3;		// 주행을 위해서 우측 센서 먼저 측정한다.
		isRightSensorsUpdated = false;		// 회전했으므로, 이전 값을 사용하지 않는다.
		isFrontSensorsUpdated = false;
		ratio_stepperSpeed1 = 1.;			// turn 이후 moveStraight()가 즉각 실행되지 않으므로, turn으로 인해 극단적으로 바뀐 ratio 값을 1.0으로 복귀시킨다. 이후 ratio는 moveStraight()로 조정될 것이다.
		ratio_stepperSpeed2 = 1.;
		}
	}
}
>>>>>

























문제
1.
우측 2센서 측정 완료되어 세워지는 우측센서플래그는, 직진과 우회전을 실행하게 해. (물론 우회전은 센서값을 비교하는 조건이 있지만, 여튼.)
전방센서플래그는, 좌회전을 실행하게 해. (물론 좌회전도 센서값을 비교하는 조건이 있지만, 여튼.)

이 플래그에 따라서 (직진, 우회전), (좌회전)을 나눠야 한다.
















// 회전 센싱조건이 복잡해질 수 있다.





















ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ endline













_8



우회전과 좌회전.





전방/우측 2센서 조건에서 실행된다.




1.
회전 도중 센싱은 의미가 있을까?



1.
단지 ratio_stepperSpeed를 변경하는 것 뿐일까?
(단지 모터 속도 변경 뿐일까?)



1.






초음파 센서가 차체의 앞에 두 개, 오른쪽에 두 개 달려 있어.
그리고 차는 오른쪽 벽을 따라 가.
좌회전은 전방 2센서의 값이 가까워지면 실행하고,
우회전은 우측 2센서의 값이 멀어지면 실행해.


초음파 센서의 특성상 벽과 25도 이상 틀어지면 측정되지 않아.
그래서 우리의 차체 구조상, 회전 동안 초음파 센싱은 의미가 없다고 생각해.




직진 주행은 구상하고 코드까지 다 완성했어.
우회전과 좌회전을 구상할 건데, 내가 놓친 게 있을까?








ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ endline








_9

20251113 추가 내용

목표 기울기를 거리(차체와 목표 지점 사이 거리)에 비례하게 만들었기 때문에, 이론적으로 예상되는 문제
->
목표를 0cm라 하고 20cm에서 10cm로 이동할 때 10초가 걸렸다면, 10cm에서 5cm로 이동할 때도 10초가 걸리며, 다음 2.5cm에도 10초가 걸린다.
->
실험 결과, 거의 동일한 결과가 나왔다.
->
두 가지 변수로 조절 가능하다.
->
1.
초음파 삼각법 계산: 거리가 멀어질수록 삼각법 계산 오차가 극심해진다. 해결해야 되나, 나중에 보정에 사용할 수 있을 것 같아 냅뒀다.
2.
차체 위치(목표 라인과 차체 사이 거리)는 차체 우측의 두 초음파 값의 평균으로 한다.
그러나 평균이 아니라 두 초음파 중 어느 초음파에 가까운 값을 사용할 수도 있다.
->
거리에 비례해 목표 기울기가 결정돼 근처에서도 오래걸리는 문제를,
거리를 의도적으로 큰 값을 사용해 근처에서도 빠르게 가게 만든다.
1. 삼각법 계산을 안 하면, 이론보다 값이 높게 나온다.
2. 차체가 바깥에서 안쪽으로 들어갈 때는 차체 위치로 뒤쪽 초음파 값을 사용하고, 안쪽에서 바깥쪽으로 나갈 때는 앞쪽 초음파 값을 사용한다.
이로 인해 예상되는 문제
->
목표 위치로 빠르게 이동하지만, 근처에서 크게 요동칠 수도 있겠다는 생각을 했다.
그러나 목표 위치 근처, 즉 차체 기울기가 작아 0°에 가까워질수록 위의 두 변수는 사라진다.
->
두 변수를 조절해 실험한 결과, 성공. 직진 주행 알고리즘 끝.










ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ endline