메모리 단편화
메모리 파편화
memory fragmentation





inline 키워드
->
멤버함수의 정의가 class 내부라면, 자동으로 inline이다.
멤버함수의 정의가 class 외부라면, 정의를 inline으로 해야 한다.





[C++]에서 타입을 비교할 때, const도 포함된다.
int*로 const int*를 받을 수 없다.
우회도 안 된다.
[C]는 상관없다.





C++ 문법
    enum class PowerStatus : uint8_t { OFF, ON };
    PowerStatus powerStatus;
    powerStatus = PowerStatus::OFF;


enum, enum class
->
그 자체로 "컴파일 타임 상수"이다.
static, const, constexpr 모두 적용되어 있다.




C++의 네 가지 타입캐스팅 문법.




C++11
constexpr (constant expression) : "컴파일 타임 상수화"

컴파일 시간에 상수를 평가하고 검증한다.

메모리 공간을 차지하지 않는다.

리터럴 타입만 사용할 수 있으므로, 타입 안정성이 강화된다.		// 리터럴 타입은 컴파일 시간에 크기와 레이아웃이 결정되는 타입이다.

컴파일 시간에 계산을 수행하여 결과적으로 메모리 사용량과 실행 시간을 최적화, 런타임 성능을 개선한다.

변수, 함수, 생성자 등 다양한 문맥에서 사용할 수 있다.

멤버변수로는 모든 객체에 대해 공통적인 하나의 컴파일 타임 상수로 하기 위해, 일반적으로 static과 함께 사용한다.

정적 컨텍스트에서 주로 사용한다.







C++11 이후로 클래스 멤버 변수를 선언 시점에서 초기화할 수 있는 기능이 추가되었다.

멤버 변수 초기화 : 생성자 이전에 클래스 정의 시점에 초기값을 지정하며, 모든 생성자에 걸쳐 일관된 초기값을 제공한다.

생성자 초기화 : 해당 생성자가 호출될 때 초기값을 설정한다.

->
class A
{
private:
    int i1 = 10;
    int i2 = 20;

public:
    A(int _a, int _b)
        : i1(_a)
        , i2(_b)
    {
    }

    A() {}
}




constexpr를 사용한 객체나 변수는 디버깅에 어느 정도 영향을 미칠 수 있습니다. constexpr 표현식은 컴파일 시간에 계산되므로, 실행 시 메모리에 별도로 존재하지 않는 경우가 많습니다. 이는 디버깅 시 해당 값이 메모리에 저장되어 있지 않다는 것을 의미할 수 있어, 전통적인 방법으로 값을 검사하거나 추적하는 것이 어려울 수 있습니다.

디버깅 시 고려사항:
메모리 할당 여부: constexpr 변수나 객체는 필요에 따라 컴파일러에 의해 메모리에 할당되지 않을 수 있습니다. 컴파일러는 constexpr 표현식의 결과를 직접 프로그램 코드에 삽입할 수 있으며, 따라서 런타임 시 해당 값에 대한 메모리 위치가 없을 수 있습니다.

디버거의 처리 방식: 대부분의 현대 IDE나 디버거는 constexpr에 대한 지원을 갖추고 있습니다. 컴파일러는 디버깅 정보에 constexpr 표현식의 결과를 포함시킬 수 있으며, 디버거는 이 정보를 사용하여 개발자가 해당 값을 볼 수 있도록 합니다. 예를 들어, Visual Studio, GDB 등은 constexpr 변수의 값을 디버깅 시 보여줄 수 있습니다.

심볼릭 정보: constexpr로 계산된 값은 실행 파일의 심볼릭 정보에 포함될 수 있으며, 이는 디버거가 해당 정보를 읽고 개발자에게 보여줄 수 있음을 의미합니다. 따라서, 값이 소스 코드 상에서 어떻게 사용되고 있는지를 추적하는 것은 가능하지만, 실시간 메모리 변경을 추적하는 것은 불가능할 수 있습니다.

실제 디버깅:
실제로 constexpr 변수를 디버깅할 때, IDE나 디버거는 다음과 같이 동작할 수 있습니다:

소스 코드 레벨에서 constexpr 결과를 보여주지만, 메모리 뷰에서는 해당 위치를 찾을 수 없습니다.
최적화 설정에 따라, constexpr 계산 결과가 다른 코드에 인라인으로 삽입되어 디버깅 정보에서 직접적으로 보이지 않을 수 있습니다.
결론:
constexpr 사용은 성능 최적화와 타입 안전성을 높이는데 도움이 되지만, 전통적인 방식으로 메모리를 직접 확인하는 디버깅 방법에는 제한을 줄 수 있습니다. 이런 경우, 프로그램의 로직을 이해하고, 컴파일러의 최적화 설정을 조절하거나, 디버거의 고급 기능을 활용하는 방법 등을 고려할 수 있습니다.












동적 프로그래밍. (dynamic programming)
동적 프로그래밍을 이용하는 방법은 계산된 값을 저장하여 중복 계산을 방지하는 방법입니다. 피보나치 수열의 경우, 매번 두 개의 바로 이전 값만 필요하기 때문에 모든 값을 저장할 필요는 없습니다. 하지만, 이 예에서는 모든 계산 값을 배열에 저장하는 방식으로 구현하겠습니다. 이 방식은 값의 재사용을 최대화하여 효율적인 계산을 가능하게 합니다.
동적 배열 생성.

메모리 사용량이 많지만, 중복 계산을 완전히 피할 수 있다.








1. 연결 리스트 또는 트리 구조
prev / next: 이전 노드와 다음 노드를 연결하는 데 사용. 양방향 연결 리스트에서 매우 일반적입니다.
parent / child: 트리 구조에서 부모 노드와 자식 노드를 나타냅니다.
left / right: 이진 트리의 왼쪽 자식과 오른쪽 자식을 가리키는 용어입니다.
2. 이벤트 처리
current / upcoming: 현재 처리 중인 이벤트와 곧 처리할 이벤트를 나타냅니다.
past / future: 과거의 이벤트와 미래의 이벤트를 구분하는 데 사용됩니다.
3. 버전 관리 또는 상태 변화
initial / final: 상태 또는 데이터의 시작점과 종료점을 나타냅니다.
old / new: 변경 전과 변경 후의 상태를 비교할 때 사용됩니다.
4. 타임라인 관리
start / end: 프로젝트, 이벤트, 또는 태스크의 시작과 끝을 나타냅니다.
before / after: 특정 시점 이전과 이후를 설명할 때 사용됩니다.
5. 기능적 진행
setup / teardown: 초기 설정과 종료 과정을 나타내는 용어입니다.
create / destroy: 객체나 자원을 생성하고 제거하는 과정을 설명합니다.













1. 과거와 현재를 나타내는 용어
prev (Previous): 이전, 보통 현재 요소의 바로 이전 요소를 가리킵니다.
curr (Current): 현재, 현재 처리 중 또는 고려 중인 요소를 가리킵니다.
last: 마지막, 주로 리스트나 배열에서 가장 최근에 추가된 요소나 가장 최근의 상태를 나타냅니다.
2. 현재와 미래를 나타내는 용어
next: 다음, 현재 요소의 바로 다음 요소를 가리키며, 특히 반복자나 리스트 처리에서 사용됩니다.
upcoming 또는 forthcoming: 곧 다가올, 주로 미래의 예정된 이벤트나 요소를 가리킬 때 사용됩니다.
3. 과거와 미래의 상태 변화를 나타내는 용어
former: 이전의, 과거의 상태나 위치 등을 설명할 때 사용됩니다.
latter: 나중의, 두 가지 중 두 번째를 가리킬 때 사용됩니다.
4. 현재 기준의 전후 상태를 나타내는 용어
pre (Prefix for Before): 전, 현재 상태나 이벤트 이전을 설명할 때 사용됩니다.
post (Prefix for After): 후, 현재 상태나 이벤트 이후를 설명할 때 사용됩니다.













https://dreamcoding.tistory.com/60
빌더 패턴, 메서드 체이닝












#define UINT32_MAX (__CONCAT(INT32_MAX, U) * 2UL + 1UL)












다차원 배열과 다중 포인터.
원리는 동일하지만, 어떻게 메모리를 이동하고 접근하는가에 차이가 있다.











C++에서의 포인터 사용은 기본적으로 C에서와 매우 유사합니다. C++은 C의 슈퍼셋이기 때문에 C의 모든 포인터 기능을 지원합니다.










허상 포인터(dangling pointer) - 해제 메모리를 가리킴.
와일드 포인터(wild pointer) - 초기화하지 않음.




함수 객체와 람다(anonymous function, 이름 없는 함수)
-> https://jidon333.github.io/blog/Function-object-and-lambda
요약
->
inline은 함수 코드가 전처리화되어 코드가 모두 전개되고, 메모리는 늘어나겠지만 오버헤드는 사라진다.
C에서 함수 포인터와 inline을 동시에 적용할 수 없다.
함수 포인터를 사용한다면 오버헤드는 필수적인 셈이다.













바인딩(binding)  :  개체 속성을 구체적으로 결정하는 것.
정적/동적 바인딩.












함수에서 다차원 배열 포인터를 받아 다차원으로 사용할 수 있다.

arr[][][] -> arr, &arr, arr[0], &arr[0], 다 다르다. 타입 확인해.
->
멀티 포인터로 배열을 받는다.
->
어떻게 받고 어떻게 읽어야 다차원을 그대로 사용할 수 있는가?










bit-field
->
typedef struct _bitfield{
    unsigned b0 : 1;
    unsigned b1 : 1;
    unsigned b2 : 1;
    unsigned b3 : 1;
    unsigned b4 : 1;
    unsigned b5 : 1;
    unsigned b6 : 1;
    unsigned b7 : 1;
} bitfield;















단일 책임 원칙(Single Responsibility Principle, SRP)은 객체 지향 프로그래밍과 소프트웨어 엔지니어링에서 중요한 디자인 원칙 중 하나입니다.
->
과도한 책임 분리는 오히려 관리가 더 복잡해질 수 있다.
성능 저하는 덤.












매직 넘버(Magic number)는 코드에서 하드 코딩된(literal value) 일정한 값을 의미하는 숫자나 문자열 등을 의미합니다. 매직넘버는 코드 내에서 여러 곳에서 사용되지만 이 값의 의미나 목적은 코드에서 명확하게 알려지지 않습니다.











extern "C"

!! 링킹 규약만 변경하며, 유일성을 보장하지는 않는다.

extern "C"는 C++ 코드에서 사용되는 특별한 문법으로, 이를 사용하면 C++ 컴파일러에게 특정 함수를 C 언어 링킹(linking) 규약을 사용하여 처리하도록 지시합니다. 이는 주로 C++ 코드가 C 언어 라이브러리나 시스템 호출과 호환되도록 할 때 사용됩니다. 다음은 extern "C"가 사용되는 몇 가지 주요 이유와 세부 사항입니다:

이름 장식(Name Mangling) 방지: C++은 함수 오버로딩을 지원하기 때문에 같은 이름의 함수라도 입력 파라미터에 따라 다른 이름으로 컴파일될 수 있습니다(이름 장식 혹은 네임 맹글링이라고 함). 반면, C 언어는 함수 오버로딩을 지원하지 않습니다. extern "C"를 사용하면 C++ 컴파일러는 해당 함수에 대해 이름 장식을 하지 않고, C 언어 스타일로 이름을 유지하게 됩니다. 이는 다른 C 라이브러리나 시스템에서 해당 함수를 찾을 수 있게 해 줍니다.

호환성: C++ 코드가 C 언어로 작성된 코드, 예를 들어 운영 체제의 API나 C 언어로 작성된 라이브러리와 상호 작용할 때 필요합니다. extern "C"를 사용함으로써 C++ 코드 내에서 선언된 함수를 C 코드에서도 호출할 수 있게 됩니다.

인터럽트 서비스 루틴(ISR)과의 호환: 많은 하드웨어 플랫폼과 OS에서 ISR은 순수 C 함수로만 정의되어야 합니다. extern "C"를 사용하여 ISR을 정의함으로써, C++에서 작성된 ISR이 하드웨어나 OS의 인터럽트 시스템과 제대로 호환될 수 있습니다.

예를 들어, extern "C" void ISR_HandleStep1()에서 extern "C"는 ISR_HandleStep1 함수가 C 언어 링킹 규약을 따르도록 하여, 시스템의 다른 C 언어로 작성된 코드나 인터럽트 관련 코드와 호환되도록 만듭니다. 이는 특히 아두이노와 같은 플랫폼에서 C++ 코드를 사용할 때 중요한 부분입니다, 왜냐하면 아두이노의 많은 라이브러리와 기본 시스템 호출이 C 언어로 작성되었기 때문입니다.




extern "C"			extern "C++"  :  링킹 규약.





// 아래의 두 예제는 같은 코드이며, 가독성의 차이이다.

// 예제1
#ifdef __cplusplus
extern "C" {
#endif

    void myCFunction1() {}

#ifdef __cplusplus
}
#endif


// 예제2
#ifdef __cplusplus
extern "C" {
    void myCFunction1() {}
}
#endif



void myCFunction1(int a) {}         // ERROR: conflicting declaration of C function         // disable overloading















ISR은 컴파일 시점에 확정되어야 한다.
ISR에서의 non-static member 사용은 일반적인 C++ 규칙이 아니며 권장하지 않는다.















    for (int x : vec) {
        std::cout << x << " ";
    }

범위 기반 for loop  :  컨테이너의 모든 요소를 반복하면서 각 요소에 대해 루프 본문을 실행하는 간편하고 직관적인 방법을 제공한다.

for (declaration : range_expression) {
    loop_statement;
}

표현식에는
고정 크기 배열,
초기화 리스트,
STL(standard template library) container,
begin(), end() method가 존재하고 iterator를 반환하여 traversing이 가능한 user-defined class/structure
이 올 수 있다.

개념적 구현
->
{
    auto && __range = range_expression;
    auto __begin = std::begin(__range);
    auto __end = std::end(__range);
    for ( ; __begin != __end; ++__begin) {
        declaration = *__begin;
        loop_statement;
    }
}

















usual arithmetic conversion (일반 산술 변환) - implicit conversion(type-coercion, 암시적 형변환)
->
uint + int -> 조건에 따라 uint, int가 될 수 있다.
정수임에도 분명하게 타입을 체크하여 명시해야 한다.
















getter, setter 메서드에 대한 질답
->
https://kin.naver.com/qna/detail.naver?d1id=1&dirId=1040101&docId=474729988#











%zu는 size_t 자료형을 출력할 때 사용하는 형식 지정자입니다.







C 표준 라이브러리 함수: 성공 0, 실패 -1 반환












stdout, stderr는 데이터 출력 경로를 의미하는 스트림이다. 둘 모두 별도로 지정하지 않는다면 출력을 consol에 할 뿐이다.
stderr는 stdout과는 별도로 버퍼링이 다를 수 있으며, 보통 stderr는 무버퍼링 또는 줄 버퍼링되고, stdout은 완전 버퍼링된다.



















data structure: vector list tuple set dictionary















googling
사이트 특정: C language write file site:stackoverflow.com
파일 타입: python machine learning filetype:ppt (pdf, 
특정 키워드 검색: "this is a message." (큰 따옴표로 묶으면 정확히 "this is a message."만을 검색한다.
+포함 -제외: +message1 -message


















UI(User Interface)

CLI(명령줄 인터페이스, Command-Line Interface) 또는 CUI(Character User Interface)
텍스트로만 이루어져 있다.
vs
GUI(Graphical User Interface)















반복문 내에 변수 선언에 대해서
-> https://mon0mon.tistory.com/27










약어, 축약: abbreviation























cpp에서 default parameter가 있다.

















ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ endline