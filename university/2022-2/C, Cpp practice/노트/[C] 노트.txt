미처리@@@@@@@@@@@@@@@@@@@@@@

아무것도아님 : (웹 등의)프레임워크, 라이브러리

참고로 C 언어에서 다국어 및 유니코드 처리는 매우 까다로운 분야입니다.
여기서는 이런 자료형과 함수가 있다는 것 정도만 알아두면 됩니다.
출처 : https://dojang.io/mod/page/view.php?id=770



#pragma once
(WARNING) C4828 파일에 0xNNN 오프셋에서 시작하는 문자가 포함되어 있습니다.
이 문자는 현자 원본 문자 집합에서 잘못된 문자입니다(코드 페이지 949).
파일  :  헤더파일
줄  :  1

미처리@@@@@@@@@@@@@@@@@@@@@@

ㅡ debug . release 정보는 삭제해도 다시 생긴다.
	디버깅 시 문제가 발생할 때 유용하다.

		1. 중단점 오류
		2. 등등



글꼴 : Consolas
외국어 글꼴에서는 Backslash가 \(원화)가 아닌 /로 표시된다.

도구 \ 옵션 \ 텍스트편집기 \ C/C++ \ 탭
탭 크기 4, 들여쓰기 크기 4, 공백 삽입

Project 속성 \ C/C++ \ 고급 \ 컴파일 옵션
C 코드로 컴파일(/TC)




#pragma once
-> 한번 읽어가면 추가적으로 읽지 않도록하는 기능
-> 헤더 파일 최상단에 #pragma once를 명시하면 해결된다.
-> 표준이 아니므로 작동하지 않을 수 있다.



(ERROR) C4996
이 경고는 항상 기호를 선언하는 헤더 파일 작성자의 의도적인 메시지입니다.
결과를 이해하지 않고 사용되지 않는 기호를 사용하지 마세요.
함수는 안전하지 않고 보다 안전한 변형을 가지므로 더 이상 사용되지 않습니다.
오류 메세지에는 일반적으로 사용되지 않는 함수 또는 전역 변수에 대한 제안된 대체 항목이 포함됩니다.
경고 끄기 참고 사이트 :
https://docs.microsoft.com/ko-kr/cpp/error-messages/compiler-warnings/compiler-warning-level-3-c4996?f1url=%3FappId%3DDev16IDEF1%26l%3DKO-KR%26k%3Dk(C4996)%26rd%3Dtrue&view=msvc-170
항목을 추가할 노트
C:\Users\bibib\OneDrive\바탕 화면\C언어\C언어 (ERROR) C4996 항목



ㅡ CRT 함수에 _s가 붙으면 보안기능이 향상된 함수들이다.

	buffer overflow에 대한 security 문제를 해결하기 위한 함수이다.

	_s 함수에 대해서, 문자 . 문자열 . 배열 등의 변수에게는 반드시 최대 길이(buffer)를 주어야 한다.
	// 버퍼 오버플로를 발생시키지 않는다면, 쓸 필요가 없기는 그냥 _s함수로 쓰삼.



Syntax[신택스]는 문법, 구조, 또는 언어 문장 내에 있는 구성요소의 순서이다.
(이에 반해 semantics는 이러한 구성요소들의 의미이다).
syntax (부호들의 상호관계에 관한 연구),
semantics (부호들과 그것들이 적용되는 개체간의 관계에 관한 연구),
pragmatics (부호체계와 사용자간의 상호관계)

data type : 자료형
( int )
instance : 객체
( a );
integer : 정수

natural number : 자연수

real number : 실수

multiple : 배수

condition variable : 조건 변수

conditional statement : 조건문

condition : 조건

statement : 문장(명령문)

expression : 표현식(수식) : variable + constant + operator
				   변수	 상수        연산자

operand : 피연산자 : variable + constant

parameter : 매개변수
함수 선언에서 정의된 변수 (Parameter is variable in the declaration of function.)
variable(변수)에 포함된다.

argument : 인자
실제로 함수에 전달되는 값 (Argument is the actual value of this variable that gets passed to function.)
value(값)에 포함된다.

variable은 value에 포함된다.

memory allocator : 메모리 할당자
allocate : 할당하다
allocation : 할당
static memory allocation : 정적 메모리 할당
dynamic memory allocation : 동적 메모리 할당

Data structure : 자료 구조(학문)
Stack(스택) : 후입 선출, 선입 후출
Queue(큐) : 선입 선출, 후입 후출
Deque(덱, Double - Ended Queue)
https://velog.io/@nnnyeong/자료구조-스택-Stack-큐-Queue-덱-Deque

C언어의 함수가 사용하는 메모리 영역 : Stack memory 영역

메모리와 코드를 동일시하지 않는다.
코드는 명령어의 집합이고,
이 코드를 수행했을 때, 그 수행에 맞춰서 동작하는 곳이 메모리 영역이다.



*** 메모리의 해제와 청소는 별도이다.
	e.g.	함수 실행 시 stack memory에 할당되며, 함수 종료 시 memory가 해제된다.
		이 때, 해당 memory를 더 이상 사용하지 않겠다는 의미로 '할당 해제'만 될 뿐이지,
		내부의 데이터가 청소되지는 않는다.
		세부 정보 : https://kin.naver.com/qna/detail.naver?d1id=1&dirId=1040101&docId=431807429
				


# : 전처리기
compile에서 가장 먼저 수행한다.

RAM, ROM 차이점  :  https://ko.gadget-info.com/difference-between-ram
ROM과 RAM을 기계 부품의 차이로 인지하자.
프로그램은 운영체제로부터 메모리 공간(RAM)을 할당받는다.
C언어의 메모리 구조  :  https://lecor.tistory.com/64
컴파일 과정  :  https://jhnyang.tistory.com/40



#include <헤더파일>과 #include "헤더파일"
해당 헤더파일이 존재하는 경로의 차이이다.

#include <헤더파일>
컴파일러가 설치된 폴더에서 헤더 파일을 찾으라는 지시이다.
예를 들어서 iostream이나 stdio.h와 같은 헤더파일은 컴파일러와 같은 폴더에 위치해 있다.
같은 경로에 있는 것이다.
따라서 <>꺽쇠로 표시해줘서 같은 경로에서 찾으라는 명령이다.
 
#include "헤더파일"
사용자의 프로젝트 폴더나 개발자가 추가포함 디렉터리로 지정해준 경로에서 찾으라는 명령이다.
개발자가 만든 헤더파일이나 추가로 외부 라이브러리를 포함하고 싶은 경우 위와 같은 명령을 사용해준다.



선언(Declaration)은 코드 일부로서 변수나 함수가 있음을 알려주는 것이고
정의(Definition)은 코드 일부로서 변수나 함수가 무엇인지 알려주는 것이다.
즉 있음을 알려주는 것이 선언, 무엇인지 알려주는 것이 정의이다.

선언은 여러번 가능하다. (할 이유가 없다.)
정의된 지역이 local이며, 정의할 때 dataType에 따른 메모리를 할당한다.
그렇기에, 같은 local 외곽에서 여러번 정의할 수 없다.  :  중복정의, 재정의 오류

e.g.  local이 함수 내인 지역변수의 경우,
그 함수 내에서 정의가 가능하다.



함수와 변수는 선언, 정의, 초기화 단계를 거쳐야 사용 가능하다.
함수는 선언, 정의.
변수는 선언, 정의, 초기화.

함수에서 기본 반환값은 1이다.



전역에서 변수 선언 시 0으로 초기화된다.
변수의 dataType을 정의하지 않을 시, int 또는 double(@@@@@)로 정의된다.

	상단에 솔루션 플랫폼 선택 - 64비트, 32비트.

	x84 (윈도우 32비트 버전) - x86라는 제품이, 32비트 시절에 x86라는 CPU가 있었다.
	32비트 환경을 x86이라고 하는게 아니라,
	통칭 x86계열의 CPU가 32비트까지 나와있고,
	여기서 64비트를 지원하도록 확장된게 x86-64죠.
	그래서 x86-64를 줄여서 간단히 x64...

	32비트는 이제 없다고 생각하면 된다.



V.S. IDE 동작방식
	solution - projects - source.header files
	project 하나가 실행파일 하나를 만든다.



포인터.

	C, C++의 강력한 특징 중 하나이다.
	메모리 관리와 더불어 주소에 직접 관여할 수 있다.
	주소라는 개념을 언어 차원에서 쓸 수 있다는 것.
	변수의 주소를 직접 받아올 수 있는 문법. 포인터.

	나는 C,C++이라는 문법을 통해서 아주 편하게 변수에 값을 넣는데,
	실제 기계어로 번역될 때는 그렇게 단순하게 동작하지 않는다.
	내가 작성한 문법을 수행하기 위해서 컴파일된 코드들은,
	메모리의 주소를 지칭하기 위해서
	특정 주소, 위치에다가 값을 넣도록 명령어가 만들어진다.

	& : 해당 변수, 함수의 주소를 나타낸다.



윈도우 메모리 구조  :  https://jungwoong.tistory.com/44

32bit 운영체제는, 명령처리의 기본 단위가 4Bytes이다.
64bit 운영체제는, 8Bytes이다.

arrayName[N]
컴퓨터 과학에서 배열이나 자료 구조 오브젝트 내의 오프셋(offset)은
일반적으로 동일 오브젝트 안에서 오브젝트 처음부터 주어진 요소나 지점까지의 변위차를 나타내는 정수형이다.
이를테면, 문자 A의 배열이 abcdef를 포함한다면 'c' 문자는 A 시작점에서 2의 오프셋을 지닌다고 할 수 있다.
어셈블리어와 같은 저급 프로그래밍 언어에서 오프셋은 상대 주소(relative address)로 부른다.



실제 컴퓨터에서는 우리가 생각하기 편하게 작성한 이진수처럼 메모리에 저장되어 있는게 아니라,
빅엔디안, 리틀 엔디안에 따라서 메모리 읽기 및 저장방식이 다릅니다.
2바이트 메모리를 읽게되면 리틀엔디안 방식에서는
앞쪽 메모리를 하위비트로 시작해서 뒤로 갈 수록 상위 비트로 인지하기 때문에
앞에 배치된 숫자가 하위 비트가 됩니다.



scope (variable scope : 변수의 유효 범위)
컴퓨터 프로그래밍에서 변수 영역은 변수가 유효성을 갖는 영역을 가리킨다.

*** basic scope : {} (braces, curly brakets)
	중괄호가 기본 scope이다. 알고 있으면 매우 유용하다.
		e.g.
		using namespace의 scope 제한.

프로그램은 영역을 벗어난 변수를 가리킬 수 없다.
변수 영역을 지정하는 규칙은 크게 정적 영역 규칙과 동적 영역 규칙으로 나뉜다.

지역 변수는 전역 변수와 대응되며,
자동 변수는 정적 변수와 대응된다.

전역 변수(extern)와 정적 변수를 선언할 때,
값을 초기화했으면 데이터 섹션(.data)에 생성되고,
초기화하지 않았으면 BSS 섹션(.bss)에 생성되며 0이 들어간다.



기억 부류 지정자 (storage class specifiers)
auto  register  static  extern
C:\Users\bibib\OneDrive\바탕 화면\C언어\사진, 캡처\storage class specifiers1

ㅡ auto
auto는 지역변수를 선언할 때 아무것도 지정하지 않았을 때 기본값으로 지정되는 storage class 이다.
함수 내에서만 선언.정의, 사용 가능하다.
(실제로 사용할 일이 거의 없다.)
변수가 생성된 뒤 자동으로 사라진다고 해서 자동 변수(automatic variable)라 부른다.
보통 지역 변수는 자동 변수로 선언하기 때문에, 자동 변수 대신 지역 변수라고 한다.

ㅡ register
register는 변수가 메모리 대신 레지스터에 저장되면 좋겠다는 희망사항을 컴파일러에게 알려주는 storage class 이다.
레지스터에 저장된 변수에는 메모리에 저장된 변수보다 훨씬 더 빠르게 접근할 수 있으므로 성능 향상을 꾀할 수 있다.
레지스터에 저장되려면 변수의 크기가 레지스터 사이즈보다 같거나 작아야 한다.
일반적으로 1 word를 저장할 수 있다.
레지스터는 메모리처럼 주소값을 갖을 수 없기 때문에,
변수의 주소값을 구하는 & 연산자는 사용할 수 없다.
실수는 레지스터형 변수가 될 수 없다.
세 개 이상의 레지스터형 변수를 선언하면,
최초 두 개 까지만 레지스터형이 되고, 나머지는 지역변수가 된다.

레지스터형 변수를 사용하는 이유는 조금이라도 더 빠른 속도를 얻기 위함이다.
대규모의 루프를 돌리는 경우 루프 제어 변수를 레지스터형으로 선언하면,
변수의 읽기 속도가 빨라지므로 전체 루프의 실행 속도가 빨라질 것이다.
register int i, j;
for (i=0;i<10000000;i++) {
for (j=0;j<1000;j++)

최근 나온 컴파일러들은 최적화를 수행하면서 레지스터를 잘 활용하기 때문에 register 지시자를 무시할 확률이 높다.
(실제로 사용할 일이 거의 없다.)

volatile과 대비되는 키워드이다.




컴파일러의 구조
C:\Users\bibib\OneDrive\바탕 화면\C언어\사진, 캡처\컴파일러의 구조1

현대의 컴파일러는 다른 것보다 code optimization이 중요시 된다.



협업 과정, 데이터가 커서 읽기 용으로 받아가려 할 때, 꼭 const*를 사용해주자.
값이 바뀌면 안되기 때문에, 상대방이 오해할 수 있다.
같은 주소를 또다른 포인터변수에 대입해서 결국 값을 바꿀 수는 있다.
이런 사람이랑은 일하지 말자.



IDE의 개발-편집기-IntelliSense(인텔리센스)
IntelliSense는 코딩을 보다 편리하게 하는 기능 집합에 지정된 이름이다.
코딩 과정에서 많은 도움을 주는 여러 기능이 포함되어 있다.



ASCII (아스키 코드) (미국정보교환표준부호) (American Standard Code for Information Interchange)
1963년 미국 ANSI에서 표준화한 정보교환용 7비트 부호체계이다.



Character Sets 종류

1. SBCS (Single Byte Character Set)  e.g. ASCII (아스키코드)
	문자를 1Byte로 표현한다.
2. MBCS (Multi Byte Character Set)
	ASCII에 더하여 한글을 2Bytes로 표현한다.
3. WBCS (Wide Byte Character Set)  e.g. Unicode (유니코드)


MBCS(멀티바이트 문자 집합) (멀티바이트 시스템) (multibyte character set)
일본어 및 중국어와 같이 싱글바이트로 표현할 수 없는 문자 집합을 지원하기 위한 이전의 접근 방식이다.
새 개발을 수행하는 경우,
최종 사용자에게 표시되지 않는 시스템 문자열을 제외한 모든 텍스트 문자열에 유니코드를 사용해야 한다.
MBCS는 Microsoft Windows에만 잔재되어 있는 시스템이다.
MBCS는 이전 기술이며 새로운 개발에는 사용하지 않는 것이 좋다.
MBCS에서 문자는 1 또는 2바이트로 인코딩된다.
e.g.    char a[10] = "abc한글";
a offset 0 ~ 9  ==  97, 98, 99, -57, -47, -79, -37, 0, 0, 0
정확한 문자열 길이 확인이 어렵다.


Unicode (유니코드)    //  wchar_t는 unsigned short형과 같으며, Unicode를 따른다.
전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준이다.
유니코드는 유니코드 협회(Unicode Consortium)가 제정한다.
또한 이 표준에는 ISO 10646 문자 집합, 문자 인코딩, 문자 정보 데이터베이스, 문자들을
다루기 위한 알고리즘 등을 포함하고 있다.
또한 유니코드의 목적은 현존하는 문자 인코딩 방법들을 모두 유니코드로 교체하려는 것이다.
기존의 인코딩들은 그 규모나 범위 면에서 한정되어 있고, 다국어 환경에서는 서로 호환되지 않는 문제점이 있었다.


VS에서 문자 집합 변경 방법 :
디버그 -> 프로젝트 속성 -> 구성 속성 -> 고급 -> 문자 집합
유니코드 문자 집합 사용 또는 멀티바이트 문자 집합 사용 을 선택할 수 있다.
ASCII와 Unicode의 크기가 다르니, 목적에 맞게 사용할 것.



== : equal to 비교연산 시, 왼쪽에 Rvalue를 배치해두는 습관을 기르자.
Rvalue = var : 런타임 에러를 컴파일 시점에서 잡을 수 있다.



mb string length 함수들은, 멀티바이트 관련 함수이다.
메모리, 문자열 등의 길이는 size_t형으로 반환된다.
typedef unsigned __int64 size_t;
따라서, 문자열 길이 반환 시, unsigned로 받을 것.

strlen은 문자열을 싱글바이트 문자열로 해석하므로,
문자열에 멀티바이트 문자가 포함되어 있더라도 해당 반환 값은 항상 바이트 수와 동일하다.
wcslen은 strlen의 와이드 문자 버전이고 wcslen의 인수는 와이드 문자열이고 문자 수는 와이드(2바이트) 문자로 계산한다.
그렇지 않으면wcslen 과 strlen 이 동일하게 작동한다.



ㅡ 문자열 길이 반환 함수  (NULL을 제외한다.)
size_t strlen(					size_t wcslen(
   const char *str				   const wchar_t *str
);						);
<string.h>					<string.h>  or  <wchar.h>



ㅡ 문자열 추가 함수 (2 parameters)
     strcat()					       wcscat()
SBCS  or  MBCS					WBCS

char *strcat(					wchar_t *wcscat(
   char *strDestination,			   wchar_t *strDestination,
   const char *strSource			   const wchar_t *strSource
);						);
<string.h>					<string.h>  or  <wchar.h>

조건  :  strDestination의 배열원소의 개수 >= wcslen(strDestination) + wcslen(strSource) + 1
조건 false	:  ERROR + 프로그램 중지

strSource를 strDestination에 추가하고 결과 문자열을 null 문자로 종료한다.
strSource의 초기 문자가 strDestination의 종료 null 문자를 덮어쓴다.
소스 문자열과 대상 문자열이 겹치는 경우 strcat의 동작이 정의되지 않는다.
strDestination에서 충분한 공간을 확인할 것.



ㅡ 문자열 추가 함수 (3 parameters)
	strcat_s()    					wcscat_s()
errno_t strcat_s(				errno_t wcscat_s(
   char *strDestination,			   wchar_t *strDestination,
   size_t numberOfElements,		   size_t numberOfElements,
   const char *strSource			   const wchar_t *strSource
);						);
<string.h>					<string.h>  or  <wchar.h>

typedef int errno_t;@@@@@@@@@@@@@2
numberOfElements  :  strDestination 배열이 쓸 수 있는 최대 문자 수. 일반적으로 대상 버퍼의 크기.

조건1  :  strDestination의 배열원소의 개수 >= wcslen(strDestination) + wcslen(strSource) + 1
조건1 false  :  WARNING - 버퍼 오버플로우  //  Dest배열의 크기와 상관없이 주소에 값이 복사된다.
조건2  :  numberOfElements >= wcslen(strDestination) + wcslen(strSource) + 1
조건2 false  :  ERROR + 프로그램 중지

함수에서 Dest배열 index 0의 주소만을 가져오기 때문에, 배열의 크기를 알 수 없다.
그러므로, numberOfElements에서 Dest배열의 크기를 적어준다.



ㅡ 문자열 비교 함수 (2 parameters)
     strcmp()					      wcscmp()
SBCS  or  MBCS					WBCS

int strcmp(					int wcscmp(
   const char *string1,			const wchar_t *string1,
   const char *string2			const wchar_t *string2
);						);
<string.h>					<string.h>  or  <wchar.h>

두 문자열을 사전 순으로 비교한다.
-cmp  :  받아올 인자는 local의 영향을 받지 않는다.
-coll   :  -coll함수의 현재 local에 속한 변수만 사용할 수 있다.
반환값  :  string1 에서 string2 순으로 index 0 부터
		대응되는 두 문자가 사전순이면   return -1;
					      같으면   return 0;
				  사전순이 아니면   return 1;



ㅡ 문자열 비교 함수 (3 parameters)
    strncmp()					    wcsncmp()
SBCS  or  MBCS				      WBCS

int strncmp(					int wcsncmp(
   const char *string1,			   const wchar_t *string1,
   const char *string2,			   const wchar_t *string2,
   size_t count				   size_t count
);						);
<string.h>					<string.h>  or  <wchar.h>

count  :  비교할 문자 수.
cmp에서 count까지만 비교한다.



오버로딩(overloading)  :  	중복 정의.

				하나의 명령어가 둘 이상의 의미를 가질 때, 컴파일러가 해석이 가능한 상황을 말한다.
				두 개의 함수가 구분이 될 경우, "함수가 오버로딩 되었다"라고 말한다.
				함수 오버로딩(function overloading)과  연산자 오버로딩(operator overloading)이 있다.
				객체지향언어에서 나온 개념이며,	
				컴파일러가 해석하여 구분하는 것을 제외한 사용자가 직접 구현하는 것에 대해서는
				C언어에서 위의 두 가지 모두 지원하지 않는다.

컴퓨터의 명령어는 기본적으로 하나의 의미만을 가지도록 되어 있다.
C++컴파일러는 C컴파일러보다 명령을 복합적으로 해석하기 때문에,
다방면에서 오버로딩이 가능하다.

ㅡ 함수 오버로딩(function overloading)
	함수의 이름이 같을 경우, 매개변수의 개수와 각각의 자료형으로 구분할 수 있다.
	C언어에서는 안된다.

ㅡ 연산자 오버로딩(operator overloading)
	e.g.	C언어에서 * 연산자는 multiplecation, pointer 두 개의 의미를 가진다.
		수식에서 * 연산자의 피연산자의 개수로 구분할 수 있다.
		* (Mul)  :  이항 연산자
		* (ptr)   :  단항 연산자



assert((void)value)		#include <assert.h>

parameter  -  (void)0  :  프로그램 중단
V.S. 에서는 Debug 모드에서만 작동하며 Release 모드에서는 동작하지 않는다.



전위연산은 Rvalue이다.
*p1++ = *p2++  :  포인터변수의 역참조 후위연산은, 역참조값이 아닌 변수값(주소값)이 오른다.
연산자 우선순위!!!!!!!!!!!!!!



메모리 누수 (memory leak)

	힙 영역에 할당된 메모리를 해제하지 않아서 발생한다.

	- 할당된 메모리의 주소값을 잃어버린 경우.

	메모리 누수를 확인할 수 있는 디버깅 전용 함수가 있다.
	search : memory leak check    메모리 누수 검사



정렬 (sort)

모든경우에 대해 최선의 정답을 내는 알고리즘은 없다.

정렬 알고리즘을 선택할때 고려해야할점으로

1. 정렬할 데이터의 양
2. 데이터와 메모리
3. 이미 정렬된 정도
4. 필요한 추가 메모리의 양
5. 상대위치 보존여부

이 다섯 가지에 따라 선택이 달라질 수 있다.

정렬 알고리즘은 7가지가 있다.
참고  :  https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html



프로세스, 멀티 태스킹, 스레드에 관하여
https://shrtorznzl.tistory.com/9



난수에 관하여. (C와 C++를 구분하여 읽을 것.)
https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=novan21&logNo=220533552199

ㅡ 난수 또는 진성 난수 (true random number)
	난수란 무작위로 만들어진 수열을 가리킨다.
	여기서 무작위란, 다음에 나올 수를 절대 예측할 수 없다는 것을 뜻한다.

ㅡ 의사 난수 (pseudo random number)
	난수는 아니나, 난수로 취급이 가능한 수열을 지칭한다.
	보통 난수를 만들 수 없는 컴퓨터 등에서 난수를 사용하기 위해서 만들어진 수열.
	충분한 숫자를 가지고 적당한 분포를 가진 수열 또는 수열을 생성 가능한 식을 통해 만들어지면 의사난수로 사용 가능하다.

의사 난수의 범위를 정할 때는 시드 값이라고 표현하는 의사 난수 생성기 초기 값을 부여하는데,
매번 부여하는 시드 값의 엔트로피가 높을수록 난수의 품질이 좋아진다.
시드가 같다면 동일한 수열이 생성된다.



ㅡ rand()  srand()			#include <stdlib.h>

rand()  :  int rand(void);
srand()  :  void srand(unsigned int seed);

	rand() 함수는 32비트 연산결과에서 상위 16비트(High order word)를 버리고 나머지 16비트만 결과 값으로 생성한다.
	난수를 발생시키는 여러 알고리즘 중 LCG(Linear Congruential Generator)의 특성상 일정 주기로 같은 값이 반복하여 나타나게 되는데,
	일반적으로 난수를 생성할 경우 하위비트 그룹 보다 상위비트의 그룹이 반복되는 주기가 더 길게 된다.
	따라서 난수 발생기들은 좀 더 좋은 품질의 난수를 생성하기 위한 빠른 방법으로 하위 비트를 잘라내는 방법을 사용하는데,
	마이크로소프트의 rand() 구현의 경우 잘라내는 크기가 16비트이기 때문에 최대로 생성할 수 있는 난수는 16비트의 최대 값인 32767이 된다.
	상수 RAND_MAX는 stdlib.h에 정의되어 있으며 0x7FFF로 정의가 되어 있음을 확인할 수 있다.

****	rand() 함수는 srand() 함수를 통해 설정되는 시드 값을 전역 변수로 사용한다.
	때문에 멀티스레드 환경에서는 srand() 함수 사용 시 변경되는 시드 값으로 인해 다른 스레드의 rand() 함수가 영향을 받지 않는지 확인해야 한다.
	비주얼 C++에서의 rand() 함수는 멀티스레드 환경에서도 안전하게 사용할 수 있지만,
	일반적으로 rand() 함수의 구현사항이 복잡하지 않기 때문에 멀티스레드 환경에서는 각 스레드 컨텍스트에 시드 값을 포함시켜 별도의 난수 생성기를 구현하는 방법을 사용하기도 한다.
	rand() 구현은 각 벤더나 시스템, 컴파일러마다 다를 수 있다.



srand() 함수를 호출하지 않을 경우, rand() 함수는 srand(1)을 호출한다.
srand() 함수를 호출할 경우, srand() 함수의 인자 . seed값으로 시간값이 많이 쓰인다.
e.g.
srand((unsigned int)time(NULL));




ㅡ time  _time32  _time64			#include <time.h>

time_t time( time_t *destTime );
__time32_t _time32( __time32_t *destTime );
__time64_t _time64( __time64_t *destTime );

	time 함수는 시스템 클럭에 따라 1970년 1월 1일 자정(00:00:00), UTC(협정 세계시) 이후 경과된 시간(초)을 반환한다.
	반환 값은 destTime로 제공된 위치에 저장된다. 이 매개 변수는 NULL일 수 있으며, 이 경우 반환 값은 저장되지 않는다.
	...



함수 호출 규칙에 대하여. ( __cdecl  __stdcall  __fastcall )
https://mattlee.tistory.com/77



C++의 객체지향.
	특정 개체가 하나의 기능을 담당해서 역할을 수행할 수 있는 것.
	각 개체만을 위한 함수가 있다.
	하나의 기능을 담당하는 구조체형을 만드는 것.



<계산 복잡도 이론 - 컴퓨터>
 - 시간 복잡도(runtime) - https://insight-bgh.tistory.com/505?category=908649
 - 공간 복잡도(allocated memory) - https://insight-bgh.tistory.com/506?category=908649

빅 오 표기법에서는 계수를 완전 무시한다. 비교하는 것이 의미가 없는 것은 아니다.



<EOF> (end of file)

	운영체제에서 파일의 끝을 탐지하는 방법은 운영체제마다 다르다.
	하지만 C언어는 운영체제와 상관없이, 파일의 끝에 도달했을 때 언제나 특별한 값을 반환한다.
	그 값을 EOF(End Of File)라고 하며, 실제로 이 값은 -1을 나타낸다.



<버퍼> (buffer)

	컴퓨터의 주 기억장치와 주변장치 사이에서 데이터를 주고받을 때,
	둘 사이의 전송속도 차이를 해결하기 위해, 전송할 정보를 임시로 저장하는 고속 기억장치이다.
	용량이 한정되어 있으며, 오버플로우가 발생할 수 있다.
	표준 입출력함수들은 모두 버퍼를 사용한다.



ㅡ [C] 표준정의와 관련 에러 설명
	참고 : https://codingstorytelling.tistory.com/8



ㅡ redirection
	쉘(shell, 셸)에서 표준 출력으로 출력하면 일반적으로 모니터에 출력하며,
	표준 입력으로 입력하면, 키보드로 입력받는다.
	그런데, 표준 출력으로 출력하는 것을 모니터가 아닌 다른 파일로 출력을 하거나,
	표준 입력으로 입력하는 것을 키보드가 아닌 다른 파일로부터 입력하게 할 수 있다.
	이를 입출력 리다이렉트(redirect) . 리디렉션(redirection)이라고 한다.
	// 지금은 표준 출력과 표준 오류가 같은 디바이스에서 같은 콘솔을 사용하지만, 나중에 리디렉션을 통해 변경할 수 있다.

	

ㅡ	putchar는 표준라이브러의 함수이며 putch는 표준 라이브러리 함수가 아닙니다.
	표준 라이브러리의 입출력 함수들은 모두 내부적으로 버퍼링을 하기 때문에 1글자 찍는다고 1글자가 그대로 찍히는게 아닙니다.
	내부에서 버퍼에 글자가 모아지면 한번에 출력하기 때문에 특문을 쪼개서 출력했다고 할지라도 정상적으로 출력될 수 있습니다.
	반면에 putch는 버퍼링없이 그대로 한글자씩 출력하기 때문에 쪼개서 찍으면 쪼개진채로 잘못된 코드가 그대로 출력됩니다.



ㅡ	두 개의 파일포인터로 커서이동의 불편함을 없애는 것으로 run-time 리소스를 줄이겠다고 한다면,
	포인터변수로서 같은 스트림을 가리키므로 이는 불가능하다.



ㅡ	파일이 닫혀있으면, 실제로 그 파일은 사용중이라며 열리지 않는다.
	"다른 프로세스가 파일을 사용 중이기 때문에 프로세스가 액세스 할 수 없습니다."



ㅡ	MATLab@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



ㅡ	C99에서 inline키워드가 추가되었다.

	C언어에서의 inline함수의 제약조건 몇 가지

		1. inline 함수의 재귀적인 호출이 불가능하다.
		2. 분기관련 명령중에서 일부의 경우 사용할 수 없다. (switch . goto . for . while . etc.)
		3. inline 함수 자신 또는 함수 내부의 static 객체를 사용할 수 없다.
		4. 하나의 문맥, 수식에서 2회 이상 사용할 수 없다.
		5. 호출하려는 위치보다 상위에 inline함수가 명시되어있어야 한다.
		6. 함수포인터에 주소를 대입할 수 없다.
		7. 위와 같은 사항에 해당되면, 컴파일러는 해당 inline함수를 일반 함수로 컴파일한다.