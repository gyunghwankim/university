[C++] : 객체지향.
클래스부터 시작.

ㅡ C++의 모든 것은 객체로 표현된다. ( 객체 지향 프로그래밍(영어: Object-Oriented Programming, OOP) )
// C언어의 함수와는 다르게, 함수와 라이브러리 등 거의 모든 것은 객체로 표현되어 있다.
	객체(object)와 C++에 대한 정보 : 
	https://boycoding.tistory.com/238?category=1067100



ㅡ C++에서는 템플릿을 이용한 일반화 프로그래밍(Generic Programming)이 매우 폭넓게 사용된다.
	특히 C++11을 시작으로 하는 모던 C++에서는 일반화 프로그래밍을 빼고 이야기하는 것이 불가능하다.
	C++ 표준 라이브러리 ( std:: ) 만 봐도 대부분이 템플릿으로 일반화가 되어 있다.
	STL(Standard Template Library)이라는 단어가, 이러한 현재 C++ 표준 라이브러리를 부르는 말이다.
	STL 참고 : http://www.tcpschool.com/cpp/cpp_container_intro
	STL 참고 : https://wiserloner.tistory.com/435
	STL = 컨테이너 + 반복자 + 알고리즘

		e.g.
		std::string		:  std::basic_string<T>
		std::vector		:  std::vector<T>
		etc.

	또한, [C]스타일 또는 [C++ 11] 이전에 쓰이던 키워드들에 비해, 템플릿을 적용시킬 수 있는 새로운 키워드가 생겨남에 따라,
	확실하게 [C]스타일과 [C++]스타일을 구분짓게 되었다.
		e.g.
		typedef		>>		using
		etc.



ㅡ C++ : 객체지향과 캡슐화를 토대로, 인터페이스와 구현을 분리한다.



ㅡ C++에서는 사용자 정의 헤더를 제외한 표준 헤더 파일들 모두 ' .h '를 사용하지 않는다.
// <iostream>과 <iostream.h>는 서로 다르지만, 구버전 컴파일의 경우 <iostream.h>를 사용하기도 한다.



ㅡ  자료구조(data structure)와 컨테이너(container)의 개념 : 참고 : https://kin.naver.com/qna/detail.naver?d1id=1&dirId=1040101&docId=427932983

ㅡ namespace (네임스페이스, 이름공간)
	개체를 구분할 수 있는 범위를 나타내는 말이다.
	일반적으로 하나의 namespace에서는, 하나의 이름이 단 하나의 개체만을 가리키게 된다.

ㅡ 객체의 속성		:  data fields			변수
ㅡ 객체의 행위, 동작	:  메서드(methods)		함수

ㅡ resource (자원) (리소스)
	C/C++ 학습 기간에는 메모리로 생각하자.

ㅡ 대입 연산자 (assignment operator)
	오른쪽 메모리의 값을 왼쪽 메모리의 값에 복사한다.

	대입의 조건.
		1.  Lvalue와 Rvalue의 개념을 만족시킨다.
		2.  dataType이 같아야 한다. (사용자 정의 자료형인 구조체와 클래스를 포함한다.)
	
	구조체와 클래스에 대한 디폴트 대입연산자는,
	대응되는 멤버변수들끼리 복사한다.

ㅡ type casting
	C스타일	  int a = (int)10;
	C++스타일	  int a = int(10);

ㅡ 모든 연산에서 타입이 맞지 않을 경우,
	암시적인 형변환이 일어나거나, 오류가 뜬다.

ㅡ 상수 (const)  리터럴 (literal)
	상수	 : 변하지 않는 변수이다.
	리터럴 : 코드에 직접 삽입된 값이다. 변경할 수 없으므로 '상수'이다.

ㅡ C++에서 사용되는 것 중 C에서 없던 기능이라면 내부적으로 C를 통해 구현되어 있을 확률이 높다.
	예시로, new 연산자는 실제로 malloc을 통해 구현되어 있다.

ㅡ interpreter (인터프리터)
	원시 언어의 명령을 번역 . 실행하는 프로그램.
	(어셈블러, 컴파일러)

ㅡ scope, namespace 차이
	scope	: 사용자 입장에서 해당 객체에 대한 문법적인 표기 가능 범위.
	namespace	: 인터프리터 입장에서 해당 객체에 대한 구분 범위.

ㅡ 사용자 정의 자료형이 멤버가 없다면, 해당 자료형의 객체의 크기는 1 Byte이다.

ㅡ 객체의 이름이 겹칠 경우, 항상 가장 안쪽의 scope에서 정의되거나 선언된 이름을 따라간다.

ㅡ [C++] 표준 라이브러리 객체들의 실제 구현코드는, 이미 컴파일되어 사용자에게 제공이 된다.
	내부를 볼 수 없으며, 헤더 . 선언만 볼 수 있다.
	하지만 같은 [C++] 언어를 쓰기 때문에, 충분히 추측이 가능하다.

ㅡ 템플릿 오버로드는 추가 옵션을 제공합니다.
	_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES를 1로 정의하면,
	더 안전한 변형을 자동으로 호출하는 표준 CRT 함수의 템플릿 오버로드가 사용하도록 설정됩니다.
	_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES가 1이면 코드를 변경할 필요가 없습니다.
	내부적으로 strcpy에 대한 호출은 자동으로 제공된 크기 인수를 사용하는 strcpy_s에 대한 호출로 변경됩니다.

ㅡ type : errno_t		:  int 타입과 같다.
	V.S.에서 함수의 에러 정보를 표현하기 위한 반환값으로 사용된다.
	에러가 아니면 0을 반환한다.

ㅡ 문자셋, 인코딩 참고 : https://bumnabi.tistory.com/entry/CharacterSet-Encoding%EC%9D%B4%EB%9E%80



ㅡ 정보 은닉 (Information Hiding)  &  캡슐화 (Encapsulation)
참고 : https://boycoding.tistory.com/243?category=1067100

	캡슐화와 정보은닉은, 클래스 디자인의 가장 기본원칙이다.

	캡슐화  :  캡슐화의 기본 이론은 관련 있는 데이터와 함수를 하나로 묶는것이다.
		     캡슐화는 정보은닉을 포함하는 개념일 수 있다.

	정보 은닉  :  정보은닉의 기본 이론은 멤버변수의 private을 기반으로 멤버 함수들의 const화, 그리고 제한된 방법으로만의 접근 허용이다.



ㅡ Accessor and Mutator Functions  :  변수에 대한 접근과 변경에 개입한다. 인터페이스와 관련이 있다.
	Getter  :  Accessor	(접근자)
	Setter  :  Mutator	(변경자)

	◎ 제한된 접근 방법
		- Get으로 시작하는 함수를 이용하여 private 멤버 변수에 접근하도록 한다. (관례)
		- Set으로 시작하는 함수를 이용하여 private 멤버 변수를 변경하도록 한다. (관례)
		- const 선언을 최대한 효율적으로 사용하여 접근제한의 안정성을 높힌다.



ㅡ C++의 auto 키워드는 자료형을 자동으로 추론하여 변수를 선언하는 기능이라 C 언어와는 전혀 다르다.



ㅡ 표준 입출력

	표준 입력 : 키보드를 통해 입력하는 것.@@@@@
	표준 출력 : 보고 있는 모니터에서 볼 수 있도록 터미널 등에서 데이터를 출력하는 것.@@@@@

	[C]	    :  <stdio.h> etc
	[C++]   :  <iostream>  <streambuf>  <istream>  <ostream>  <ios>  etc

	<iostream>
	iostream 구조 : C:\Users\bibib\OneDrive\바탕 화면\C언어\[C++]\iostream 구조
	표준 스트림에서 읽기 및 쓰기를 제어하는 개체를 선언한다.
	이 포함은 C++ 프로그램에서 입력 및 출력을 수행하는 데 필요한 유일한 헤더인 경우가 많다.

	<streambuf>  <istream>  <ostream>  <ios>  etc
	위의 헤더들은, 일반적으로 다른 iostreams 헤더에 의해 포함된다. 직접 포함할 필요가 거의 없다.



ㅡ C와 C++의 표준 입출력의 차이점

	C	 :  변수와 dataType을 지정해야 한다.		( printf  scanf )
	C++	 :  변수만 지정하면 된다.					( cin  cout )		c : OS's 'c'onsole (콘솔 창)

	C++ 컴파일러는, 사용자의 실수를 방지해줄 목적으로, 가장 알맞은 자료형을 선택해준다.
	<iostream> 등의 입출력 헤더로도 printf  scanf 를 사용할 수 있듯이,
	C++에서 dataType을 직접 지정할 수도 있다.



ㅡ 함수 오버로딩

	함수의 이름이 같아도, 매개변수나 스코프가 다르면
	서로 다른 함수이다.



ㅡ 연산자 오버로딩에 관하여 필요한 지식.

	ㅡ 복사 생성자  :  객체의 복사가 이루어질 때 호출되는 생성자이다.
				    클래스 내에서 일반 생성자는 파라미터를 다르게 하여서 여러 개를 둘 수 있지만,
				    복사 생성자는 파라미터를 자기 클래스 타입의 참조 변수 하나만 가지기 때문에
				    하나의 복사 생성자만 존재할 수 있다.



	ㅡ 얕은 복사와 깊은 복사.

		객체의 멤버로는 일반변수 뿐만 아니라, 참조변수도 있을 수 있다.
		일반변수에 대한 복사 방법은 같다.
		참조변수에 대한 복사 방법에 따라 얕은 복사와 깊은 복사로 나뉜다.


		얕은 복사  :  참조변수가 가지는 주소값만 복사한다.
				 멤버 대 멤버의 복사 방식으로, 디폴트 복사 생성자가 얕은 복사이다.
				 (멤버변수 중 참조변수에 대하여 주소값을 공유하게 된다.  ==  모두가 참조되는 객체를 바라본다.)

		깊은 복사  :  복사받는 참조변수가 가리킬 객체를 새로 할당하고, 참조변수는 새로운 객체를 가리킨다.

		얕은 복사와 짙은 복사에 대한 예시.
		https://wonjayk.tistory.com/256



ㅡ 오버라이딩(overrriding)     :	재정의.

					부모클래스에서 상속받은 함수를 자식클래스에서 다른 기능으로 사용하기 위해, 같은 이름으로 재정의하는 것.



ㅡ 함수 사용 시의 장점.	     :	1. 함수 내부의 코드를 재사용할 수 있다.

					2. 인스턴트 코드보다 함수에서 코드를 변경하거나 업데이트하기가 더 쉽다.

					3. 함수 이름을 통해 코드가 무엇을 의미하는지 이해하기 더 쉽다.

					4. 함수는 함수 호출 인수가 함수 매개 변수와 일치하는지 확인하기 위해 타입 검사를 한다. (매크로는 안한다.)
 
					5. 함수는 프로그램을 디버그하기 쉽게 만든다.



			단점	     :	1. 함수 호출 비용이 든다. (오버헤드가 있다.)

					CPU가 다른 레지스터와 함께 실행 중인 현재 명령어의 주소를 저장해야 하므로(나중에 반환할 위치를 알 수 있도록)
					모든 함수 매개 변수를 생성해야 한다.
					할당된 값을 사용하면 프로그램이 새 위치로 분기된다.
					내부에서 작성된 코드(인스턴트 코드)가 훨씬 더 빠르다.

					크거나 복잡한 태스크를 수행하는 함수의 경우, 오버헤드는 무시되는 수준이다.



ㅡ 오버헤드(overhead)	     :	어떤 명령어를 처리하는데 소비되는 간접적, 추가적인 컴퓨터 자원을 말한다.
					예를들어, 10초 걸리는 기능이 간접적인 원인으로 20초가 걸린다면, 오버헤드는 10초가 되는것이다.

					언어차원에서 오버헤드는 외부함수를 인라인 처리를 할 때와 하지 않을 때의 시간 차이,
					즉, 함수 호출 과정으로 인한 추가시간이다.

					프로그램의 실행흐름 도중에 동떨어진 위치의 코드를 실행하는,
					함수를 호출할때 함수 내용이 아닌 함수를 호출하는데 들어가는 비용이다.

					예를 들어, 호출하고자 하는 함수의 실행시간이 길다면, 상대적으로 문제가 덜하다.
					이와 반대로, 반복문에 짧은 외부함수가 하나 들어가 있는 경우 문제가 극심하다. (inline, macro로 오버헤드 최소화 가능.)

					이러한 오버헤드 현상은 피할 수 없으며,
					[C++]에서는 이를 위해 인라인(inline) 함수를 제공한다.



ㅡ 인라인 함수(inline function) :	C++은 내부에서 작성된 코드의 속도와 함수의 장점을 결합하는 inline 방법을 제공한다.
					// C99에서도 inline 키워드가 추가됐으며, '[C] 지식'에 정리했다.

					compile-time에 모든 인라인 함수가 인-플레이스(in-place) 확장된다.
					즉, 함수 호출이 함수 자체의 내용 복사본으로 대체되어 함수 오버헤드가 제거된다.
					어셈블리어에서 함수 호출 과정은 사라지고 함수에 있는 몸통부분만 실행되는 것을 확인할 수 있다.

					함수를 호출하는 데 걸리는 시간, 오버헤드가 사라지지만, 함수 호출 과정으로 생기는 여러 이점을 포기해야 한다.
					따라서, 내부 루프가 없는 짧은 함수에 적합하다.

					inline 키워드는 함수의 원형이나 함수의 정의 어느 한 쪽에만 표기해도 적용되며, 물론 양쪽 다 표기해도 된다.



			     단점   :	1. 실행코드가 늘어나고, 컴파일 시간이 길어지고, 실행파일이 커진다.

					현대 컴파일러는 자동으로 함수를 인라인화 하는 데 매우 뛰어나다.
					인라인 함수를 알고 있어야 하지만, 최신 컴파일러는 함수를 적절하게 인라인화 하므로 inline 키워드를 사용할 필요가 없으며,
					반대로 컴파일러는 인라인에 대한 요청을 자유롭게 무시할 수 있다. (긴 함수를 인라인화 하려고 하면 무시할 가능성이 있다.)

					inline 키워드는 권장 사항일 뿐이다.



ㅡ type은 크게 primitive type 과 user-defined type 으로 나뉜다.
	primitive type : 기본 자료형
	user-defined type : 사용자 정의 자료형



ㅡ POD (Plain Old Data), non-POD

***	우선, malloc은 오로지 POD타입에 대해서만 크기를 할당해줄 수 있다.

		1. 사용자 정의 생성자나 복사 배정연산자, 소멸자가 없는,			==  built-in type
		2. 그리고 모든 non-static 멤버들이 참조가 아니고,				==  가상함수가 없고 사용자 정의 할당자와 소멸자를 가지지 않는 class object
		3. 멤버를 가리키는 포인터도 아니며, non-POD도 아닌 클래스나 공용체  ==  non-POD를 non-static 멤버로 가지지 않은 class object
		를 말한다.

		// 비공식적으로
		// POD == 보통의 자료형
		// 단, 편의를 위한 사용자 정의 멤버함수를 가질 수는 있다.

		// POD는 메모리 이미지를 컴파일 시점에서 생성하고,
		// 그것을 프로그램의 실행 파일 이미지에 직접 넣을 수 있는 DataType이다.

		위의 세 가지 조건을 충족한다면, C언어의 struct처럼 object를 사용할 수 있다.

		간추리면,
		1. POD는 연속된 메모리를 가진 자료형이다.
	***	2. C언어와 호환이 가능한 자료형이다.

		C++의 <type_traits> 헤더의 is_pod 를 이용하여 확인할 수 있다.

			예시 1.
			클래스 객체 초기화나 복사 등의 연산을 memset 이나 memcpy 로 사용하는 것은,
			"메모리 블럭을 통째로 수정하는 함수는 POD타입 객체에만 사용해야 한다." 라는 명백한 표준 위반이다.

		C언어의 malloc/free  VS  C++의 new/delete
		https://kkoding.tistory.com/12
		https://wonjayk.tistory.com/252

		객체가 아니고 빈번하게 재할당을 해야 한다면,
		코드 가독성을 충분히 고려하고 malloc/free 를 사용할 수 있으나,
		아니고서는 C++에서 new/delete 만을 사용한다.



ㅡ 	클래스 선언만 했다면 아직 정의되지 않은 상황이기 때문에, 클래스 객체를 생성하지 못한다.
	하지만, 주소 참조는 된다.
	아래의 예시가 있다.

		class B;
		class A
		{
		    B* m_p;         // no error

		    B m_i;          // ERROR C2079 : A::m_i 는 정의되지 않은 class B 를 사용합니다.
		};

		class B
		{
		private:
			m_i;
		};



ㅡ 디폴트 전위 . 후위 연산자.

	[C]	    :	디폴트 전위 연산자 . 디폴트 후위 연산자 둘 다 Lvalue를 반환한다.

	[C++]	    :	디폴트 전위 연산자는 Rvalue를 반환하고,
			디폴트 후위 연산자는 Lvalue를 반환한다.